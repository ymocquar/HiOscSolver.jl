var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [HiOscSolver]\nOrder   = [:function]","category":"page"},{"location":"functions/#DiffEqBase.solve-Union{Tuple{HiOscODEProblem{T}}, Tuple{T}} where T<:AbstractFloat","page":"Functions","title":"DiffEqBase.solve","text":"function DiffEqBase.solve(prob::HiOscODEProblem{T}; \nnb_tau::Integer=32, \norder::Integer=4, \norder_prep::Integer=order+2, \ndense::Bool=true, \nnb_t::Integer=100, \ngetprecision::Bool=dense,\nverbose=100,\npar_u0::Union{PrepareU0,Missing}=missing,\np_coef::Union{CoefExpAB,Missing}=missing\n) where T<:AbstractFloat\n\nsolver for Highly oscillatory problems, that an ODE of this form fracdelta u(t)delta t = frac1varepsilon A + F(u(t) t) where u in R^n and  0  varepsilon  1 A must be a periodic matrix i.e. e^t A = e^(t+pi) A for any t in R\n\nArgument :\n\nprob::HiOscODEProblem{T} : The problem to solve\n\nKeywords :\n\nnb_tau::Integer=32 : number of values of FFT transform, must be power of twoscalespureab\norder::Integer=4 : order of Adams-Bashforth method, and also of the interpolatation\norder_prep::Integer=order+2 : order of the preparation\ndense::Bool=true : if true it is possible to compute solution at any time of the interval\nnb_t::Integer=100 : number of period slices\ngetprecision::Bool=dense : compute the absolute and relative precision\npar_u0::Union{PrepareU0,Missing}=missing : preparation data for u0\np_coef::Union{CoefExpAB,Missing}=missing : coefficients for Adams-Bashforth method\n\nExamples :\n\n\n\n\n\n","category":"method"},{"location":"functions/#HiOscSolver.twoscales_pure_ab-Tuple{HiOscSolver.PrepareTwoScalesPureAB}","page":"Functions","title":"HiOscSolver.twoscales_pure_ab","text":"twoscales_pure_ab(par::PrepareTwoScalesPureAB; only_end::Bool=false, diff_fft::Bool=false, res_fft::Bool=false, verbose::Integer=100)\n\ncompute the data to get solution of the differential equation\n\nArguments :\n\npar::PrepareTwoScalesPureAB : contains all the parameters and prepared data\n\nKeywords :\n\nonly_end=false : if true return only the result for t_end\ndiff_fft::Bool=false : if true return data about diff\nres_fft::Bool=false : if true return u_caret data indispensable for interpolation\nverbose::Integer: level off traces (0 means no output)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Polynomials.derivative-Tuple{HiOscSolver.PolyExp}","page":"Functions","title":"Polynomials.derivative","text":"derivative(pe::PolyExp)\n\nConstruct the derivative of the pe function.\n\nExamples\n\njulia> derivative(PolyExp([1, 3, -1],3,1))\nPolyExp(Polynomial(6 + 7*x - 3*x^2)*exp(3*x + 1))\n\njulia> derivative(PolyExp([1.0+im, 3im, -1, 4.0], 2.0+1.5im,1.0im))\nPolyExp(Polynomial((0.5 + 6.5im) - (6.5 - 6.0im)*x + (10.0 - 1.5im)*x^2 + (8.0 + 6.0im)*x^3)*exp((2.0 + 1.5im)*x + 1.0im))\n\n\n\n\n\n","category":"method"},{"location":"functions/#Polynomials.integrate-Tuple{HiOscSolver.PolyExp}","page":"Functions","title":"Polynomials.integrate","text":"integrate(pe::PolyExp)\n\nConstruct the integrate function of pe which is of PolyExp type. The algorithm used is a recursive integration by parts.\n\nExamples\n\njulia> integrate(PolyExp([1.0,2,3],2.0,5.0))\nPolyExp(Polynomial(0.75 - 0.5*x + 1.5*x^2)*exp(2.0*x + 5.0))\n\njulia> integrate(PolyExp([1.0+0im,2],2.0im,3.0+0im))\nPolyExp(Polynomial((0.5 - 0.5im) - 1.0im*x)*exp(2.0im*x + 3.0))\n\n\n\n\n\n","category":"method"},{"location":"doc/#Numerical-method","page":"Numerical method","title":"Numerical method","text":"","category":"section"},{"location":"doc/#Two-scale-formulation","page":"Numerical method","title":"Two-scale formulation","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"First, rewrite equation (1) using the variable change w(t)=exp(-(t-t_0)Avarepsilon) u(t) to obtain","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracd w(t)dt = FBig( fract-t_0varepsilon w(t) Big)  w(t_0)=u_0  varepsilonin 0 1","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"where the function F is expressed from the data of the original problem (1)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"FBig( fracsvarepsilon w Big) = exp(-sAvarepsilon)  f( exp(sAvarepsilon)  w)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"We then introduce the function U(t tau) tauin 0 2 pi such that U(t tau=(t-t_0)varepsilon) = w(t). The two-scale function is then the solution of the following equation","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracpartial Upartial t + frac1varepsilon fracpartial Upartial tau =  F( tau U)  U(t=t_0 tau)=Phi(tau)  varepsilonin 0 1  (2)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"where Phi is a function checking Phi(tau=0)=u_0 chosen so that the U solution of (2) is regular (see Philippe Chartier , Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2015) and Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020).","category":"page"},{"location":"doc/#Discretization","page":"Numerical method","title":"Discretization","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"The numerical method is based on a suitable time discretization of equation (2). In the direction tau, a spectral method is used, while for the time t, an exponential Adams-Bashforth method allows to build a high order method (see Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020)). The suitable choice of the initial condition is required to ensure high order accuracy. From a numerical point of view, a \"butterfly\" technique is introduced here (going back and forth around the initial time).","category":"page"},{"location":"doc/#Initialization","page":"Numerical method","title":"Initialization","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Let r be the order of the method AB_r.\nLet Delta t the time step, for i in r -(r-1) ldots r-1 r, we note u_i = u(t_0+i Delta t).\nLet r be the orders of the intermediate AB methods we will use.\nIf u_k is known with a precision of mathcal O(Delta t^r+1), and for r geq 2 u_k-1 ldots u_k-r+1 are known with a precision of mathcal O(Delta t^r) then we can calculate u_k+1 with a precision of mathcal O(Delta t^r+1) with the method AB_r.\nSimilarly, if u_k is known with a precision of mathcal O(Delta t^r+1), and for r geq 2 u_k+1 ldots u_k+r-1 are known with a precision of mathcal O(Delta t^r) then we can calculate u_k-1 with a precision of mathcal O(Delta t^r+1) with the method AB_r.","category":"page"},{"location":"doc/#Algorithm","page":"Numerical method","title":"Algorithm","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"With the method AB_1, from u_0 we calculate u_-1 with a precision of mathcal O(Delta t^2)\nWith the method AB_2, starting from u_0 and u_-1, we calculate u_1 with a precision of mathcal O(Delta t^3)\nFor r = 3 to r = r.\nFor k=1 to k=r-1\nWith the method AB_r-1, from u_1-k u_2-k ldotsu_r-1-k, we calculate u_-k with a precision of cal O(Delta t^r)\nFor k=1 to k=r-1\nWith the method AB_r, from u_k-1 u_k-2 ldotsu_k-r, we calculate u_k with a precision of mathcal O(Delta t^r+1)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"At the end of this algorithm, the values u_0 u_1 ldots u_r-1 are known with a precision of mathcal O(Delta t^r+1), we can launch the algorithm AB_r.","category":"page"},{"location":"doc/#The-Adams-Bashforth-Method","page":"Numerical method","title":"The Adams-Bashforth Method","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"For an Adams-Bashforth method of order r in time and spectral tau, we first introduce a mesh in the tau direction.\ntau_ell = ell Delta tau ell = 0 ldots N_tau-1. Where N_tau is the number of points of discretization. If we apply the Fourier transform to the two-scale equation, we obtain ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracpartial hatU_ellpartial t + fraciellvarepsilonhatU_ell = hatF_ell(t)  ell=-N_tau2 dots N_tau2-1","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"with","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"U(t tau_k) = sum_ell=-N_tau2^N_tau2-1 hatU_ell(t) e^iell k 2piN_tau  text and  F(tau_k U(t tau_k)) = sum_ell=-N_tau2^N_tau2-1 hatF_ell(t) e^iell k 2piN_tau","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"and the inverse (discrete) Fourier transform formulae","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"hatU_ell(t) = frac1N_tausum_k=0^N_tau-1 U(t tau_k) e^-iell k 2piN_tau text and  hatF_ell(t) = frac1N_tausum_k=0^N_tau-1 F(tau_k U(t tau_k))e^-iell k 2piN_tau","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"If we wish to calculate hatF_ell from hatU_ell we have the following formula ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"F(tau_kU(t tau_k)) = e^-tau_k Af(e^tau_k AU(t tau_k)) ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"from which the Fourier transform is calculated in tau from the discrete Fourier transform formulas above.","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Now, given a time step Delta t0 and a discretization in time t_n=nDelta t, we can write the following Duhamel formula (ngeq 0)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"hatU_ell(t_n+1) \n= e^-iellDelta tvarepsilonhatU_ell(t_n)  + int_0^Delta t e^-iell(Delta t -s)varepsilon hatF_ell(t_n+s)ds","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Thus, to obtain a (r+1) scheme, we can  approaches the function hatF_ell(t_n+s) by the Lagrange polynomial of order r interpolator at points t_n-j j=0 dots r. This polynomial is written ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"hatF_ell(t_n+s) approx sum_k=0^r Big(Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta t Big) hatF_ell(t_n-t_j)  ngeq 0","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Thus, from this approximation, we integrate exactly, which requires the following formulas","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"p^r_ell j = int_0^Delta te^-iell(Delta t -s)varepsilonBig( Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta tBig) ds","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"for each j and ell such that 0leq jleq r  ell=-N_tau2 dots N_tau2-1. These coefficients p^r_ell j can be pre-calculated and stored once and for all. Thus, the schema is finally written","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"hatU_ell^n+1= e^-iellDelta tvarepsilonhatU_ell^n + sum_j=0^r p^r_ell j hatF_ell^n-j","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"with hatU_ell^n approx hatU_ell(t_n) and hatF_ell^n-japprox hatF_ell(t_n-j). ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"We can verify that the truncation error in this schema is  mathcal O(Delta t^r+1), once the initial values  hatU_ell^1 dots hatU_ell^r have been calculated.  ","category":"page"},{"location":"doc/#Non-homogeneous-case-f(u,-t)","page":"Numerical method","title":"Non-homogeneous case f(u t)","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Here we consider the case where f depends on the variable t.","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracd u(t)dt = frac1varepsilon A u(t) + f(u(t) t)  u(t=t_0)=u_0  varepsilonin 0 1  (3)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"The non-homogeneous case (3) falls under (1), by entering the variable  theta  t in t_0 t_textend mapsto theta(t) = tin mathbbR  which allows us to reformulate the non-homogeneous case (3) into a homogeneous problem of the form (1). Indeed, we rephrase (3) as follows","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"beginaligned\nfracd u(t) dt   = frac1varepsilon Au(t) + f(u(t) theta(t)) \nfracd theta(t) dt   = 1\nendaligned(4)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"with the initial condition  u(t_0)=u_0 theta(t_0)=t_0. Thus, the problem (4) is rewritten into an equation\nsatisfied by y tin t_0 t_fin mapsto y(t) =(u(t) theta(t))in mathbbR^n+1","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracd ydt = frac1varepsilon tildeA y + g(y)  y(t_0)=(u_0 t_0)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"with tildeAinmathcal M_n+1 n+1(mathbbR)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"tildeA=\nleft(\nbeginarraycccc\n             0 \n    A       0 \n            0 \n0  0  0   0 \nendarray\nright)  text and  \ng(y)=g(u theta) = left(\nbeginarraycccccc\nf(u theta) \n1\nendarray\nright) in mathbbR^n+1","category":"page"},{"location":"doc/#Use","page":"Numerical method","title":"Use","text":"","category":"section"},{"location":"doc/#Input-parameters","page":"Numerical method","title":"Input parameters","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"The input arguments use the same format as the ODE package. ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Thus, first of all, we must define the arguments necessary to construct the problem (1), namely","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"the f function (in the form Julia) \nthe initial condition u_0.\nthe initial time t_0 and final time t_fin. \nthe second parameter of the \nthe A matrix \nvarepsilon in 0 1","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"pkg'add https://gitlab.inria.fr/ua/HiOscSolver.jl.git'\nusing HiOscSolver\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nfct = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] \nepsilon= 0.0001\nt_min=0.0\nt_max=3.0\nu0 = [0.55, 0.12, 0.03, 0.89]\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon) ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"From the prob problem, we can now switch to its digital resolution. ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"To do this, the numerical parameters are defined ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"the number of time slots N_t which defines the time step Delta t = fract_textend-t_0N_t \nthe r order of the method \nthe number of N_tau points in the tau direction... \nthe order of preparation q of the initial condition ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"The default settings are : N_t=100, r=4, N_tau=32 and q=r+2=6 To solve the problem with the default parameters, just call the solve command with the problem already defined as parameter","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"sol = solve(prob) ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Which is equivalent to this call","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"sol = solve(\n    prob;\n    nb_tau=32, \n    order=4, \n    order_prep=6, # by default : order + 2\n    dense=true, \n    nb_t=100, \n    getprecision=true, # by default : dense \n    verbose=100,    \n    par_u0=missing,\n    p_coef=missing,\n) ","category":"page"},{"location":"doc/#Exhaustive-definition-of-the-parameters","page":"Numerical method","title":"Exhaustive definition of the parameters","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"prob : problem defined by HiOscODEProblem \nnb_tau=32 : N_tau\norder=4 : order r of the method\norder_prep=order+2 : order of preparation of initial data\ndense=true : indicates whether or not to keep the data from the fourier transform, if dense=false, processing is faster but interpolation can no longer be done.\nnb_t=100 : N_t\ngetprecision=dense : indicates whether the accuracy is calculated, the method used to calculate the accuracy multiplies the processing time by 2.\nverbose=100 : trace level, if verbose=0 then nothing is displayed.\npar_u0 : If we have to make several calls to solve with the same initial data and in the same order, we can pass in parameter the already calculated data.\np_coef : table with the coefficients of the Adams-Bashforth method. This array can be used to optimize several calls with the same parameters.","category":"page"},{"location":"doc/#Exit-arguments","page":"Numerical method","title":"Exit arguments","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"As an output, a structure of type HiOscODESolution. This structure can be seen as a function of t, it can also be seen as an array of size N_t + 1. This structure also contains the absprec and relprec fields which are the absolute and relative precisions, respectively, calculated.","category":"page"},{"location":"doc/#Example","page":"Numerical method","title":"Example","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"julia> sol = solve(prob);\nsolve function prob=HiOscODEProblem with uType Array{Float64,1} and tType Float64. In-place: nothing\ntimespan: (0.0, 3.0)\nu0: [0.55, 0.12, 0.03, 0.89],\n nb_tau=32, order=4, order_prep=6, dense=true,\n nb_t=100, getprecision=true, verbose=100\n\nx 100/100\n\n 99/99\n\njulia> t=2.541451547\n2.541451547\n\njulia> sol(t)\n4-element Array{Float64,1}:\n -0.536667845897295\n  1.593257176840297\n -0.12420061944907212\n  0.7184374612958457\n\njulia> sol[end]\n4-element Array{Float64,1}:\n  0.36316109321808354\n  2.0379196624858955\n -0.4141248638226731\n  1.3087136174628513\n\njulia> sol(3.0)\n4-element Array{Float64,1}:\n  0.36316109321808626\n  2.037919662485913\n -0.4141248638226772\n  1.308713617462862\n\njulia> sol.absprec\n2.4721022528746903e-5\n\njulia> sol.relprec\n9.952927361881597e-6\n\n","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"To view the result, you can also use Plot, for example","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"using Plots\nplot(sol) ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"This results in","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"(Image: )","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"If you want to save the result in a file (pdf or png) here are the commands","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"using Plots\np = plot(sol)\nsavefig(p,\"out/plot.png\")","category":"page"},{"location":"doc/#Examples","page":"Numerical method","title":"Examples","text":"","category":"section"},{"location":"doc/#Hénon-Heiles","page":"Numerical method","title":"Hénon-Heiles","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"We consider the system of Hénon-Heiles satisfied by u(t)=(u_1 u_2 u_3 u_4)(t).","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracd u dt = frac1varepsilon Au + f(u)  u(0)=u_0inmathbbR^4","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"where A and f are selected as follows","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright)  text and  \nf(u) = left(\nbeginarraycccc\n0 \nu_4\n-2 u_1 u_2\n-u_2-u_1^2+u_2^2\nendarray\nright)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"one chooses for example, varepsilon=0001 and u_0 = (012 012 012 012)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"using HiOscSolver\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nfct = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] \nepsilon= 0.001\nt_min=0.0\nt_max=1.0\nu0 = [0.12, 0.12, 0.12, 0.12]\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon)\nsol = solve(prob);\nusing Plots\nplot(sol)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"(Image: )","category":"page"},{"location":"doc/#Charged-particle","page":"Numerical method","title":"Charged particle","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"A system of charged particles under the effect of an external electro-magnetic field is considered to be  (E(t x) B(t x))in mathbbR^6.\nParticles are dynamically described by their position  x(t)inmathbbR^3 and their speed v(t)inmathbbR^3. We'll index by i the i-th component of a vector. Newton's equations applied to a particle can be written as","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"beginaligned\nfracd x(t) dt= v(t) \nfracd v(t) dt= fracem leftE(t x(t)) + v(t)times B(t x(t))right \nendaligned","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"We will assume that the magnetic field is written B(t x)=(0 0 1)^T and under a certain scaling, we consider the following equation","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"beginaligned\nfracd x_1(t) dt = frac1varepsilonv_1(t) \nfracd x_2(t) dt = frac1varepsilon v_2(t) \nfracd x_3(t) dt = v_3(t) \nfracd v_1(t) dt = E_1(t x(t)) + frac1varepsilonv_2(t)\nfracd v_2(t) dt = E_2(t x(t)) - frac1varepsilonv_1(t)\nfracd v_3(t) dt = E_3(t x(t)) \nendaligned","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"which is rewritten as follows","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracd u(t) dt= frac1varepsilonA u(t) + F(t u(t))","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"where the unknown vector u(t)=(x(t) v(t))inmathbbR^6, A is a square matrix of size 6times 6 and F is a function with a value in mathbbR^6. A and F are given by","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"A=\nleft(\nbeginarraycccccc\n0  0  0  1  0  0 \n0  0  0  0  1  0 \n0  0  0  0  0  0 \n0  0  0  0  1  0 \n0  0  0  -1  0  0 \n0  0  0  0  0  0 \nendarray\nright)  text and  \nF(t u(t)) = left(\nbeginarraycccccc\n0 \n0\nu_6(t)\nE_1(t u_1(t) u_2(t) u_3(t))\nE_2(t  u_1(t) u_2(t) u_3(t)\nE_3(t  u_1(t) u_2(t) u_3(t)\nendarray\nright)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"We can consider the following E=(E_1 E_2 E_3) function","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"E(t x) =\nleft(\nbeginarrayccc\ncos(x_12)sin(x_2)sin(x_3)2\nsin(x_12)cos(x_2)sin(x_3)\nsin(x_12)sin(x_2)cos(x_3)\nendarray\nright)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"using HiOscSolver\nA = [0 0 0 1 0 0; 0 0 0 0 1 0;0 0 0 0 0 0; 0 0 0 0 1 0; 0 0 0 -1 0 0; 0 0 0 0 0 0]\nfunction fparticle(u, p, t)\n    s1, c1 = sincos(u[1]/2)\n    s2, c2 = sincos(u[2])\n    s3, c3 = sincos(u[3])\n    return [0, 0, u[6], c1*s2*s3/2, s1*c2*s3, s1*s2*c3]\nend\nepsilon= 0.05\nt_min=0.0\nt_max=1.0\nu0 = [1.0, 1.5, -0.5, 0, -1.2, 0.8]\nprob = HiOscODEProblem(fparticle, u0, (t_min,t_max), missing, A, epsilon)\nsol=solve(prob)\nplot(sol)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"(Image: )","category":"page"},{"location":"doc/#Linear-non-homogeneous-case","page":"Numerical method","title":"Linear non-homogeneous case","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"The following non-homogeneous linear system is considered to be satisfied by u(t)=(u_1 u_2 u_3 u_4)(t)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracd u dt = frac1varepsilon Au + f(t u)  u(0)=u_0inmathbbR^4","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"where A and f are selected as follows","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright)  text and  \nf(t u) = Bu +alpha t +beta  text with   \nBin mathcal M_4 4(mathbbR) alpha beta in mathbbR^4","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"B alpha beta are chosen randomly.","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"We wish to obtain a high precision, so we will use BigFloat real numbers, they are encoded on 256 bits by default which gives a precision bound of about 2^-256 approx 10^-77.\nAt the end, we compare a calculated result with an exact result.","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"using HiOscSolver\nusing Random\nRandom.seed!(1111)\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nB = 2rand(BigFloat, 4, 4) - ones(BigFloat, 4, 4)\nalpha = 2rand(BigFloat, 4) - ones(BigFloat, 4)\nbeta = 2rand(BigFloat, 4) - ones(BigFloat, 4)\nfct = (u,p,t)-> B*u + t*p[1] +p[2]\nu0 = [big\"0.5\", big\"-0.123\", big\"0.8\", big\"0.7\"]\nt_min=big\"0.0\"\nt_max=big\"1.0\"\nepsilon=big\"0.017\"\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), (alpha, beta), A, epsilon, B)\nsol = solve(prob, nb_t=10000, order=8)\nsol.absprec\nt=big\"0.9756534187771\"\nsol(t)-getexactsol(sol.par_u0.parphi, u0, t)\nusing Plots\nPlots.plot(sol.t,sol.u_tr)","category":"page"},{"location":"doc/#Calculation-of-the-exact-solution","page":"Numerical method","title":"Calculation of the exact solution","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"This involves calculating the exact solution u(t) of the following equation at the instant t","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"fracd u dt = frac1varepsilon Au + Bu +alpha t +beta  u(0)=u_0inmathbbR^4text  A text and B text are defined above ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Let","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"beginaligned\n    M = frac1varepsilon A + B\n    C = e^-t_0 Mu_0 +M^-1 e^-t_0 M (t_0alpha+beta)+ M^-2 e^-t_0 M alpha\n    C_t = -M^-1 e^-t M (talpha+beta)-M^-2 e^-t M alpha\n    u(t) = e^t M ( C + C_t)\nendaligned","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Which, translated into Julia language, gives the code of the function getexactsol : ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"function getexactsol(par::PreparePhi, u0, t)\n    @assert !ismissing(par.matrix_B) \"The debug matrix is not defined\"\n    sparse_A = par.sparse_Ap[1:(end-1),1:(end-1)]\n    m = (1/par.epsilon)*sparse_A+par.matrix_B\n    t0 = par.t_0\n    if ismissing(par.paramfct)\n        return exp((t-t0)*m)*u0\n    end\n    a, b = par.paramfct\n    mm1 = m^(-1)\n    mm2 = mm1^2\n    e_t0 = exp(-t0*m)\n    C = e_t0*u0 + mm1*e_t0*(t0*a+b)+mm2*e_t0*a\n    e_inv = exp(-t*m)\n    e = exp(t*m)\n    C_t = -mm1*e_inv*(t*a+b)-mm2*e_inv*a\n    return e*C+e*C_t\nend\n","category":"page"},{"location":"doc/#Accuracy-of-the-result-according-to-the-time-interval","page":"Numerical method","title":"Accuracy of the result according to the time interval","text":"","category":"section"},{"location":"doc/#Linear-problem","page":"Numerical method","title":"Linear problem","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"From a problem of the previous type, as long as we can calculate the exact solution, it is possible to know exactly what the error is. The initialization data being","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"using HiOscSolver\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nu0 = BigFloat.([-34//100, 78//100, 67//100, -56//10])\nB = BigFloat.([12//100 -78//100 91//100 34//100\n    -45//100 56//100 3//100 54//100\n    -67//100 09//100 18//100 89//100\n    -91//100 -56//100 11//100 -56//100])\nalpha =  BigFloat.([12//100, -98//100, 45//100, 26//100])\nbeta =  BigFloat.([-4//100, 48//100, 23//100, -87//100])\nepsilon = 0.015\nt_max = big\"1.0\"\nfct = (u,p,t)-> B*u + t*p[1] +p[2]\nprob = HiOscODEProblem(fct,u0, (big\"0.0\",t_max), (alpha, beta), A, epsilon, B)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Note that the floats are coded on 512 bits.\nBy varying Delta t from 10^-2 to 510^-6 (i.e. nb_t from 100 to 204800) on a logarithmic scale, for odd orders from 3 to 17 we get these errors","category":"page"},{"location":"doc/#Precision-of-the-result-with-ε-0.015","page":"Numerical method","title":"Precision of the result with ε = 0.015","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"(Image: )","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Now with the same initial data, order being setted to 6, and varepsilon = 015 0015 ldots 15times 10^-7.\nHere floats are coded on 256 bits.","category":"page"},{"location":"doc/#Precision-of-the-result-with-order-6","page":"Numerical method","title":"Precision of the result with order = 6","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"(Image: )","category":"page"},{"location":"doc/#Problem-with-Hénon-Heiles-function","page":"Numerical method","title":"Problem with Hénon-Heiles function","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"    u0=BigFloat.([90, -44, 83, 13]//100)\n    t_max = big\"1.0\"\n    epsilon=big\"0.0017\"\n    fct = u -> [0, u[4], -2u[1]*u[2], -u[2]-u[1]^2+u[2]^2]\n    A = [0 0 1 0; 0 0 0 0;-1 0 0 0; 0 0 0 0]\n    prob = HiOscODEProblem(fct, u0, (big\"0.0\",t_max), missing, A, epsilon)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"The float are coded on 512 bits.","category":"page"},{"location":"doc/#Precision-of-the-result-with-ε-0.0017","page":"Numerical method","title":"Precision of the result with ε = 0.0017","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"(Image: )","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Now with the same initial data, order being setted to 6, and varepsilon = 019 0019 ldots 19times 10^-8.\nHere floats are coded on 256 bits.","category":"page"},{"location":"doc/#Precision-of-the-result-with-ordre-6","page":"Numerical method","title":"Precision of the result with ordre = 6","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"(Image: )","category":"page"},{"location":"doc/#Future-work","page":"Numerical method","title":"Future work","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"precision on parameter.\nexponential runge-kutta method","category":"page"},{"location":"doc/#The-\"classical\"-Runge-Kutta-method-(order-4)-adapted-to-the-exponential-(not-yet-implemented)","page":"Numerical method","title":"The \"classical\" Runge-Kutta method (order 4) adapted to the exponential (not yet implemented)","text":"","category":"section"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Notations : ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"We denote by G the function which transforms hatU to hatf, so G(hatU) = hatf.\nWe denote by S_t_0^t_1(t_2ell) the intégral S_t_0^t_1(t_2ell) = int_t_0^t_1 e^- i ell (t_2 - s)varepsilon ds = ( i varepsilon  ell) ( e^- i ell (t_2 - t_1)varepsilon-e^- i ell (t_2 - t_0)varepsilon)","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"Here are the calculations","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"u_1ell = hatU_n ell\nu_2ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell ) G_ell(u_1)\nu_3ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell )  G_ell(u_2)\nu_4ell = e^- i ell h_n (2varepsilon)u_2ell + S_0^h_n2 ( h_n2ell ) 2 G_ell(u_3)-G_ell(u_1) (see (28) of S.M. Cox , P.C. Matthews  (2002), with c=-i ell h_n varepsilon)   ","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"From (29) of S.M. Cox , P.C. Matthews  (2002), with c=-i ell h_n varepsilon, we have","category":"page"},{"location":"doc/","page":"Numerical method","title":"Numerical method","text":"hatU_n+1 ell = e^- i ell h_n varepsilonhatU_n ell +  G_ell(u_1) -4+i ell h_n varepsilon + e^-i ell h_n varepsilon(4+3i ell h_n varepsilon+(i ell h_n varepsilon)^2+ (2 G_ell(u_2) + G_ell(u_3) )-2-i ell h_n varepsilon+e^-i ell h_n varepsilon(2-i ell h_n varepsilon) + G_ell(u_4)-4+3i ell h_n varepsilon -(i ell h_n varepsilon)^2 + e^-i ell h_n varepsilon(4+i ell h_n varepsilon)(h_n^2 (i ell h_n varepsilon)^3)","category":"page"},{"location":"charged_particle/#Charged-particle-Example","page":"Charged Particle","title":"Charged particle Example","text":"","category":"section"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"A system of charged particles under the effect of an external electro-magnetic field is considered to be  (E(t x) B(t x))in mathbbR^6.\nParticles are dynamically described by their position  x(t)inmathbbR^3 and their speed v(t)inmathbbR^3. We'll index by i the i-th component of a vector. Newton's equations applied to a particle can be written as","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"beginaligned\nfracd x(t) dt= v(t) \nfracd v(t) dt= fracem leftE(t x(t)) + v(t)times B(t x(t))right \nendaligned","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"We will assume that the magnetic field is written B(t x)=(0 0 1)^T and under a certain scaling, we consider the following equation","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"beginaligned\nfracd x_1(t) dt = frac1varepsilonv_1(t) \nfracd x_2(t) dt = frac1varepsilon v_2(t) \nfracd x_3(t) dt = v_3(t) \nfracd v_1(t) dt = E_1(t x(t)) + frac1varepsilonv_2(t)\nfracd v_2(t) dt = E_2(t x(t)) - frac1varepsilonv_1(t)\nfracd v_3(t) dt = E_3(t x(t)) \nendaligned","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"which is rewritten as follows","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"fracd u(t) dt= frac1varepsilonA u(t) + F(t u(t))","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"where the unknown vector u(t)=(x(t) v(t))inmathbbR^6, A is a square matrix of size 6times 6 and F is a function with a value in mathbbR^6. A and F are given by","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"A=\nleft(\nbeginarraycccccc\n0  0  0  1  0  0 \n0  0  0  0  1  0 \n0  0  0  0  0  0 \n0  0  0  0  1  0 \n0  0  0  -1  0  0 \n0  0  0  0  0  0 \nendarray\nright)  text and  \nF(t u(t)) = left(\nbeginarraycccccc\n0 \n0\nu_6(t)\nE_1(t u_1(t) u_2(t) u_3(t))\nE_2(t  u_1(t) u_2(t) u_3(t)\nE_3(t  u_1(t) u_2(t) u_3(t)\nendarray\nright)","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"We can consider the following E=(E_1 E_2 E_3) function","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"E(t x) =\nleft(\nbeginarrayccc\ncos(x_12)sin(x_2)sin(x_3)2\nsin(x_12)cos(x_2)sin(x_3)\nsin(x_12)sin(x_2)cos(x_3)\nendarray\nright)","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"using HiOscSolver\nusing Plots","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"A = [0 0 0  1 0 0; \n     0 0 0  0 1 0;\n     0 0 0  0 0 0; \n     0 0 0  0 1 0; \n     0 0 0 -1 0 0; \n     0 0 0  0 0 0]\n\nfunction fparticle(u, p, t)\n    s1, c1 = sincos(u[1]/2)\n    s2, c2 = sincos(u[2])\n    s3, c3 = sincos(u[3])\n    return [0, 0, u[6], c1*s2*s3/2, s1*c2*s3, s1*s2*c3]\nend\n\nepsilon = 0.05\nt_min = 0.0\nt_max = 1.0\nu0 = [1.0, 1.5, -0.5, 0, -1.2, 0.8]\nprob = HiOscODEProblem(fparticle, u0, (t_min,t_max), missing, A, epsilon)\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"plot(sol,vars=(1,2,3))","category":"page"},{"location":"henon_heiles/#Hénon-Heiles-Example","page":"Henon-Heiles","title":"Hénon-Heiles Example","text":"","category":"section"},{"location":"henon_heiles/","page":"Henon-Heiles","title":"Henon-Heiles","text":"We consider the system of Hénon-Heiles satisfied by u(t)=(u_1 u_2 u_3 u_4)(t).","category":"page"},{"location":"henon_heiles/","page":"Henon-Heiles","title":"Henon-Heiles","text":"fracd u dt = frac1varepsilon Au + f(u)  u(0)=u_0inmathbbR^4","category":"page"},{"location":"henon_heiles/","page":"Henon-Heiles","title":"Henon-Heiles","text":"where A and f are selected as follows","category":"page"},{"location":"henon_heiles/","page":"Henon-Heiles","title":"Henon-Heiles","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright)  text and  \nf(u) = left(\nbeginarraycccc\n0 \nu_4\n-2 u_1 u_2\n-u_2-u_1^2+u_2^2\nendarray\nright)","category":"page"},{"location":"henon_heiles/","page":"Henon-Heiles","title":"Henon-Heiles","text":"one chooses for example, varepsilon=0001 and u_0 = (012 012 012 012)","category":"page"},{"location":"henon_heiles/","page":"Henon-Heiles","title":"Henon-Heiles","text":"using HiOscSolver\nusing Plots","category":"page"},{"location":"henon_heiles/","page":"Henon-Heiles","title":"Henon-Heiles","text":"A = [0 0 1 0 ; \n     0 0 0 0 ; \n    -1 0 0 0 ; \n     0 0 0 0 ]\n\nfct = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] \n\nepsilon= 0.001\nt_min=0.0\nt_max=1.0\nu0 = [0.12, 0.12, 0.12, 0.12]\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon)\nsol = solve(prob);\nplot(sol)","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Input-parameters","page":"Quickstart","title":"Input parameters","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The input arguments use the same format as the ODE package. ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Thus, first of all, we must define the arguments necessary to construct the problem (1), namely","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"the f function (in the form Julia) \nthe initial condition u_0.\nthe initial time t_0 and final time t_fin. \nthe second parameter of the \nthe A matrix \nvarepsilon in 0 1","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using HiOscSolver\n\nA = [ 0 0 1 0 ; \n      0 0 0 0 ; \n     -1 0 0 0 ; \n      0 0 0 0 ]\n\nfct = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] \n\nepsilon= 0.0001\n\nt_min=0.0\nt_max=3.0\n\nu0 = [0.55, 0.12, 0.03, 0.89]\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon); ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"From the prob problem, we can now switch to its digital resolution. ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To do this, the numerical parameters are defined ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"the number of time slots N_t which defines the time step Delta t = fract_textend-t_0N_t \nthe r order of the method \nthe number of N_tau points in the tau direction... \nthe order of preparation q of the initial condition ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The default settings are : N_t=100, r=4, N_tau=32 and q=r+2=6 To solve the problem with the default parameters, just call the solve command with the problem already defined as parameter","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"sol = solve(prob) ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Which is equivalent to this call","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"sol = solve(\n    prob;\n    nb_tau=32, \n    order=4, \n    order_prep=6, # by default : order + 2\n    dense=true, \n    nb_t=100, \n    getprecision=true, # by default : dense \n    verbose=100,    \n    par_u0=missing,\n    p_coef=missing,\n) ","category":"page"},{"location":"quickstart/#Exhaustive-definition-of-the-parameters","page":"Quickstart","title":"Exhaustive definition of the parameters","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"prob : problem defined by HiOscODEProblem \nnb_tau=32 : N_tau\norder=4 : order r of the method\norder_prep=order+2 : order of preparation of initial data\ndense=true : indicates whether or not to keep the data from the fourier transform, if dense=false, processing is faster but interpolation can no longer be done.\nnb_t=100 : N_t\ngetprecision=dense : indicates whether the accuracy is calculated, the method used to calculate the accuracy multiplies the processing time by 2.\nverbose=100 : trace level, if verbose=0 then nothing is displayed.\npar_u0 : If we have to make several calls to solve with the same initial data and in the same order, we can pass in parameter the already calculated data.\np_coef : table with the coefficients of the Adams-Bashforth method. This array can be used to optimize several calls with the same parameters.","category":"page"},{"location":"quickstart/#Exit-arguments","page":"Quickstart","title":"Exit arguments","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"As an output, a structure of type HiOscODESolution. This structure can be seen as a function of t, it can also be seen as an array of size N_t + 1. This structure also contains the absprec and relprec fields which are the absolute and relative precisions, respectively, calculated.","category":"page"},{"location":"quickstart/#Example","page":"Quickstart","title":"Example","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"sol = solve(prob);\nt=2.541451547\nsol(t)\nsol[end]\nsol(3.0)\nsol.absprec\nsol.relprec","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To view the result, you can also use Plot, for example","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using Plots\nplot(sol) ","category":"page"},{"location":"quickstart/#Linear-non-homogeneous-case","page":"Quickstart","title":"Linear non-homogeneous case","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The following non-homogeneous linear system is considered to be satisfied by u(t)=(u_1 u_2 u_3 u_4)(t)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"fracd u dt = frac1varepsilon Au + f(t u)  u(0)=u_0inmathbbR^4","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"where A and f are selected as follows","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright)  text and  \nf(t u) = Bu +alpha t +beta  text with   \nBin mathcal M_4 4(mathbbR) alpha beta in mathbbR^4","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"B alpha beta are chosen randomly.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We wish to obtain a high precision, so we will use BigFloat real numbers, they are encoded on 256 bits by default which gives a precision bound of about 2^-256 approx 10^-77.\nAt the end, we compare a calculated result with an exact result.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using HiOscSolver\nusing Plots\nusing Random","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"\nrng = MersenneTwister(1111)\n\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nB = 2rand(rng, BigFloat, 4, 4) - ones(BigFloat, 4, 4)\nalpha = 2rand(rng, BigFloat, 4) - ones(BigFloat, 4)\nbeta = 2rand(rng, BigFloat, 4) - ones(BigFloat, 4)\nfct = (u,p,t)-> B*u + t*p[1] +p[2]\nu0 = [big\"0.5\", big\"-0.123\", big\"0.8\", big\"0.7\"]\nt_min=big\"0.0\"\nt_max=big\"1.0\"\nepsilon=big\"0.017\"\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), (alpha, beta), A, epsilon, B)\nsol = solve(prob, nb_t=10000, order=8)\nsol.absprec","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"t=big\"0.9756534187771\"\nsol(t)-getexactsol(sol.par_u0.parphi, u0, t)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot(sol.t,sol.u_tr)","category":"page"},{"location":"quickstart/#Calculation-of-the-exact-solution","page":"Quickstart","title":"Calculation of the exact solution","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This involves calculating the exact solution u(t) of the following equation at the instant t","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"fracd u dt = frac1varepsilon Au + Bu +alpha t +beta  u(0)=u_0inmathbbR^4text  A text and B text are defined above ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Let","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"beginaligned\n    M = frac1varepsilon A + B\n    C = e^-t_0 Mu_0 +M^-1 e^-t_0 M (t_0alpha+beta)+ M^-2 e^-t_0 M alpha\n    C_t = -M^-1 e^-t M (talpha+beta)-M^-2 e^-t M alpha\n    u(t) = e^t M ( C + C_t)\nendaligned","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Which, translated into Julia language, gives the code of the function getexactsol : ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"function getexactsol(par::PreparePhi, u0, t)\n    @assert !ismissing(par.matrix_B) \"The debug matrix is not defined\"\n    sparse_A = par.sparse_Ap[1:(end-1),1:(end-1)]\n    m = (1/par.epsilon)*sparse_A+par.matrix_B\n    t0 = par.t_0\n    if ismissing(par.paramfct)\n        return exp((t-t0)*m)*u0\n    end\n    a, b = par.paramfct\n    mm1 = m^(-1)\n    mm2 = mm1^2\n    e_t0 = exp(-t0*m)\n    C = e_t0*u0 + mm1*e_t0*(t0*a+b)+mm2*e_t0*a\n    e_inv = exp(-t*m)\n    e = exp(t*m)\n    C_t = -mm1*e_inv*(t*a+b)-mm2*e_inv*a\n    return e*C+e*C_t\nend\n","category":"page"},{"location":"quickstart/#Accuracy-of-the-result-according-to-the-time-interval","page":"Quickstart","title":"Accuracy of the result according to the time interval","text":"","category":"section"},{"location":"quickstart/#Linear-problem","page":"Quickstart","title":"Linear problem","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"From a problem of the previous type, as long as we can calculate the exact solution, it is possible to know exactly what the error is. The initialization data being","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using HiOscSolver\n\nA = [0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\n\nu0 = BigFloat.([-34//100, 78//100, 67//100, -56//10])\n\nB = BigFloat.([12//100 -78//100 91//100 34//100\n    -45//100 56//100 3//100 54//100\n    -67//100 09//100 18//100 89//100\n    -91//100 -56//100 11//100 -56//100])\n\nalpha =  BigFloat.([12//100, -98//100, 45//100, 26//100])\n\nbeta =  BigFloat.([-4//100, 48//100, 23//100, -87//100])\n\nepsilon = 0.015\n\nt_max = big\"1.0\"\n\nfct = (u,p,t)-> B*u + t*p[1] +p[2]\n\nprob = HiOscODEProblem(fct,u0, (big\"0.0\",t_max), (alpha, beta), A, epsilon, B)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Note that the floats are coded on 512 bits.\nBy varying Delta t from 10^-2 to 510^-6 (i.e. nb_t from 100 to 204800) on a logarithmic scale, for odd orders from 3 to 17 we get these errors","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-ε-0.015","page":"Quickstart","title":"Precision of the result with ε = 0.015","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now with the same initial data, order being setted to 6, and varepsilon = 015 0015 ldots 15times 10^-7.\nHere floats are coded on 256 bits.","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-order-6","page":"Quickstart","title":"Precision of the result with order = 6","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#Problem-with-Hénon-Heiles-function","page":"Quickstart","title":"Problem with Hénon-Heiles function","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"u0=BigFloat.([90, -44, 83, 13]//100)\nt_max = big\"1.0\"\nepsilon=big\"0.0017\"\nfct = u -> [0, u[4], -2u[1]*u[2], -u[2]-u[1]^2+u[2]^2]\nA = [0 0 1 0; 0 0 0 0;-1 0 0 0; 0 0 0 0]\nprob = HiOscODEProblem(fct, u0, (big\"0.0\",t_max), missing, A, epsilon)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The float are coded on 512 bits.","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-ε-0.0017","page":"Quickstart","title":"Precision of the result with ε = 0.0017","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now with the same initial data, order being setted to 6, and varepsilon = 019 0019 ldots 19times 10^-8.\nHere floats are coded on 256 bits.","category":"page"},{"location":"quickstart/#Precision-of-the-result-with-ordre-6","page":"Quickstart","title":"Precision of the result with ordre = 6","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"future_work/#Future-work","page":"Future work","title":"Future work","text":"","category":"section"},{"location":"future_work/","page":"Future work","title":"Future work","text":"precision on parameter.\nexponential runge-kutta method","category":"page"},{"location":"future_work/#The-\"classical\"-Runge-Kutta-method-(order-4)-adapted-to-the-exponential-(not-yet-implemented)","page":"Future work","title":"The \"classical\" Runge-Kutta method (order 4) adapted to the exponential (not yet implemented)","text":"","category":"section"},{"location":"future_work/","page":"Future work","title":"Future work","text":"Notations : ","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"We denote by G the function which transforms hatU to hatf, so G(hatU) = hatf.\nWe denote by S_t_0^t_1(t_2ell) the intégral S_t_0^t_1(t_2ell) = int_t_0^t_1 e^- i ell (t_2 - s)varepsilon ds = ( i varepsilon  ell) ( e^- i ell (t_2 - t_1)varepsilon-e^- i ell (t_2 - t_0)varepsilon)","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"Here are the calculations","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"u_1ell = hatU_n ell\nu_2ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell ) G_ell(u_1)\nu_3ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell )  G_ell(u_2)\nu_4ell = e^- i ell h_n (2varepsilon)u_2ell + S_0^h_n2 ( h_n2ell ) 2 G_ell(u_3)-G_ell(u_1) (see (28) of S.M. Cox , P.C. Matthews  (2002), with c=-i ell h_n varepsilon)   ","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"From (29) of S.M. Cox , P.C. Matthews  (2002), with c=-i ell h_n varepsilon, we have","category":"page"},{"location":"future_work/","page":"Future work","title":"Future work","text":"hatU_n+1 ell = e^- i ell h_n varepsilonhatU_n ell +  G_ell(u_1) -4+i ell h_n varepsilon + e^-i ell h_n varepsilon(4+3i ell h_n varepsilon+(i ell h_n varepsilon)^2+ (2 G_ell(u_2) + G_ell(u_3) )-2-i ell h_n varepsilon+e^-i ell h_n varepsilon(2-i ell h_n varepsilon) + G_ell(u_4)-4+3i ell h_n varepsilon -(i ell h_n varepsilon)^2 + e^-i ell h_n varepsilon(4+i ell h_n varepsilon)(h_n^2 (i ell h_n varepsilon)^3)","category":"page"},{"location":"numerical_method/#Numerical-method","page":"Numerical Method","title":"Numerical method","text":"","category":"section"},{"location":"numerical_method/#Two-scale-formulation","page":"Numerical Method","title":"Two-scale formulation","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"First, rewrite equation (1) using the variable change w(t)=exp(-(t-t_0)Avarepsilon) u(t) to obtain","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracd w(t)dt = FBig( fract-t_0varepsilon w(t) Big)  w(t_0)=u_0  varepsilonin 0 1","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"where the function F is expressed from the data of the original problem (1)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"FBig( fracsvarepsilon w Big) = exp(-sAvarepsilon)  f( exp(sAvarepsilon)  w)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"We then introduce the function U(t tau) tauin 0 2 pi such that U(t tau=(t-t_0)varepsilon) = w(t). The two-scale function is then the solution of the following equation","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracpartial Upartial t + frac1varepsilon fracpartial Upartial tau =  F( tau U)  U(t=t_0 tau)=Phi(tau)  varepsilonin 0 1  (2)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"where Phi is a function checking Phi(tau=0)=u_0 chosen so that the U solution of (2) is regular (see Philippe Chartier , Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2015) and Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020).","category":"page"},{"location":"numerical_method/#Discretization","page":"Numerical Method","title":"Discretization","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"The numerical method is based on a discretization of equation (2). In the direction tau, a spectral method is used, while for the time t, an exponential Adams-Bashforth method allows to build a high order method (see Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020)). The initialization is based on a \"butterfly\" technique (going back and forth around the initial time).","category":"page"},{"location":"numerical_method/#Initialization","page":"Numerical Method","title":"Initialization","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Let r be the order of the method AB_r.\nLet Delta t the time step, for i in r -(r-1) ldots r-1 r, we note u_i = u(t_0+i Delta t).\nLet r be the orders of the intermediate AB methods we will use.\nIf u_k is known with a precision of mathcal O(Delta t^r+1), and for r geq 2 u_k-1 ldots u_k-r+1 are known with a precision of mathcal O(Delta t^r) then we can calculate u_k+1 with a precision of mathcal O(Delta t^r+1) with the method AB_r.\nSimilarly, if u_k is known with a precision of mathcal O(Delta t^r+1), and for r geq 2 u_k+1 ldots u_k+r-1 are known with a precision of mathcal O(Delta t^r) then we can calculate u_k-1 with a precision of mathcal O(Delta t^r+1) with the method AB_r.","category":"page"},{"location":"numerical_method/#Algorithm","page":"Numerical Method","title":"Algorithm","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"With the method AB_1, from u_0 we calculate u_-1 with a precision of mathcal O(Delta t^2)\nWith the method AB_2, starting from u_0 and u_-1, we calculate u_1 with a precision of mathcal O(Delta t^3)\nFor r = 3 to r = r.\nFor k=1 to k=r-1\nWith the method AB_r-1, from u_1-k u_2-k ldotsu_r-1-k, we calculate u_-k with a precision of mathcal O(Delta t^r)\nFor k=1 to k=r-1\nWith the method AB_r, from u_k-1 u_k-2 ldotsu_k-r, we calculate u_k with a precision of mathcal O(Delta t^r+1)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"At the end of this algorithm, the values u_0 u_1 ldots u_r-1 are known with a precision of mathcal O(Delta t^r+1), we can launch the algorithm AB_r.","category":"page"},{"location":"numerical_method/#The-Adams-Bashforth-Method","page":"Numerical Method","title":"The Adams-Bashforth Method","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"For an Adams-Bashforth method of order r in time and spectral tau, we first introduce a mesh in the tau direction.\ntau_ell = ell Delta tau ell = 0 ldots N_tau-1. Where N_tau is the number of points of discretization. If we apply the Fourier transform to the two-scale equation, we obtain ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracpartial hatU_ellpartial t + fraciellvarepsilonhatU_ell = hatF_ell(t)  ell=-N_tau2 dots N_tau2-1","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"U(t tau_k) = sum_ell=-N_tau2^N_tau2-1 hatU_ell(t) e^iell k 2piN_tau  text and  F(tau_k U(t tau_k)) = sum_ell=-N_tau2^N_tau2-1 hatF_ell(t) e^iell k 2piN_tau","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"and the inverse (discrete) Fourier transform formulae","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatU_ell(t) = frac1N_tausum_k=0^N_tau-1 U(t tau_k) e^-iell k 2piN_tau text and  hatF_ell(t) = frac1N_tausum_k=0^N_tau-1 F(tau_k U(t tau_k))e^-iell k 2piN_tau","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"If we wish to calculate hatF_ell from hatU_ell we have the following formula ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"F(tau_kU(t tau_k)) = e^-tau_k Af(e^tau_k AU(t tau_k)) ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"from which the Fourier transform is calculated in tau from the discrete Fourier transform formulas above.","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Now, given a time step Delta t0 and a discretization in time t_n=nDelta t, we can write the following Duhamel formula (ngeq 0)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatU_ell(t_n+1) \n= e^-iellDelta tvarepsilonhatU_ell(t_n)  + int_0^Delta t e^-iell(Delta t -s)varepsilon hatF_ell(t_n+s)ds","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Thus, to obtain a (r+1) scheme, we can  approaches the function hatF_ell(t_n+s) by the Lagrange polynomial of order r interpolator at points t_n-j j=0 dots r. This polynomial is written ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatF_ell(t_n+s) approx sum_k=0^r Big(Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta t Big) hatF_ell(t_n-t_j)  ngeq 0","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Thus, from this approximation, we integrate exactly, which requires the following formulas","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"p^r_ell j = int_0^Delta te^-iell(Delta t -s)varepsilonBig( Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta tBig) ds","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"for each j and ell such that 0leq jleq r  ell=-N_tau2 dots N_tau2-1. These coefficients p^r_ell j can be pre-calculated and stored once and for all. Thus, the schema is finally written","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"hatU_ell^n+1= e^-iellDelta tvarepsilonhatU_ell^n + sum_j=0^r p^r_ell j hatF_ell^n-j","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with hatU_ell^n approx hatU_ell(t_n) and hatF_ell^n-japprox hatF_ell(t_n-j). ","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"We can verify that the truncation error in this schema is  mathcal O(Delta t^r+1), once the initial values  hatU_ell^1 dots hatU_ell^r have been calculated.  ","category":"page"},{"location":"numerical_method/#Non-homogeneous-case-f(u,-t)","page":"Numerical Method","title":"Non-homogeneous case f(u t)","text":"","category":"section"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"Here we consider the case where f depends on the variable t.","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracd u(t)dt = frac1varepsilon A u(t) + f(u(t) t)  u(t=t_0)=u_0  varepsilonin 0 1  (3)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"The non-homogeneous case (3) falls under (1), by entering the variable  theta  t in t_0 t_textend mapsto theta(t) = tin mathbbR  which allows us to reformulate the non-homogeneous case (3) into a homogeneous problem of the form (1). Indeed, we rephrase (3) as follows","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"beginaligned\nfracd u(t) dt   = frac1varepsilon Au(t) + f(u(t) theta(t)) \nfracd theta(t) dt   = 1\nendaligned(4)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with the initial condition  u(t_0)=u_0 theta(t_0)=t_0. Thus, the problem (4) is rewritten into an equation\nsatisfied by y tin t_0 t_fin mapsto y(t) =(u(t) theta(t))in mathbbR^n+1","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"fracd ydt = frac1varepsilon tildeA y + g(y)  y(t_0)=(u_0 t_0)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"with tildeAinmathcal M_n+1 n+1(mathbbR)","category":"page"},{"location":"numerical_method/","page":"Numerical Method","title":"Numerical Method","text":"tildeA=\nleft(\nbeginarraycccc\n             0 \n    A       0 \n            0 \n0  0  0   0 \nendarray\nright)  text and  \ng(y)=g(u theta) = left(\nbeginarraycccccc\nf(u theta) \n1\nendarray\nright) in mathbbR^n+1","category":"page"},{"location":"docfr/#HiOscSolver.jl","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"L'objectif de ce package Julia consiste à valoriser les développements récents effectués au sein de MINGuS sur les méthodes numériques Uniformément Précises (UA pour Uniformly Accurate) pour les problèmes hautement oscillants. On se propose de résoudre l'équation suivante","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd u(t)dt = frac1varepsilon A u(t) + f(u(t)) qquad u(t=t_0)=u_0 qquad varepsilonin 0 1 qquad (1)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"avec ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"u  tin t_0 t_fin mapsto u(t)in mathbbR^n t_0 t_finin mathbbR\nu_0in mathbbR^n \nAin mathcalM_nn(mathbbR)text est telle que tau mapsto exp(tau A) est périodique,  \nf  uin  mathbbR^n mapsto mathbbR^n.","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Il s'agit ici d'écrire une documentation explicative du package Julia contenant la méthode double-échelle (voir Philippe Chartier , Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2015), Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020) et Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2013). Ce package s'inspire du package Differential Equations  qui est considéré comme un des meilleurs packages Julia existant. ","category":"page"},{"location":"docfr/#Méthode-numérique","page":"HiOscSolver.jl","title":"Méthode numérique","text":"","category":"section"},{"location":"docfr/#Formulation-double-échelle","page":"HiOscSolver.jl","title":"Formulation double-échelle","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Dans un premier temps, on réécrit l'équation (1) à l'aide du  changement d'inconnue w(t)=exp(-(t-t_0)Avarepsilon) u(t) pour obtenir ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd w(t)dt = F( fract-t_0varepsilon w(t) ) qquad w(t_0)=u_0 qquad varepsilon in 0 1","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"où la fonction F s'exprime à partir des données du problème original (1) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"FBig( fracsvarepsilon w Big) = exp(-sAvarepsilon)  f( exp(sAvarepsilon)  w) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On introduit alors la fonction U(t tau) tauin 0 2pi telle que U(t tau=(t-t_0)varepsilon) = w(t). La fonnction double-échelle est alors solution de l'équation suivante ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracpartial Upartial t + frac1varepsilon fracpartial Upartial tau =  F( tau U)  U(t=t_0 tau)=Phi(tau)  varepsilonin 0 1  (2)\nlabeleq_tau","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"où Phi est une fonction vérifiant Phi(tau=0)=u_0 choisie de sorte que la solution U de (2) est régulière (voir Philippe Chartier , Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2015) et Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020)). ","category":"page"},{"location":"docfr/#Discrétisation","page":"HiOscSolver.jl","title":"Discrétisation","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"La méthode numérique est basée sur une discrétisation de l'équation (2). Dans la direction tau, une méthode spectrale est utilisée alors que pour le temps t, une méthode de type exponentielle Adams-Bashforth permet de construire une méthode d'ordre élevé (voir Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020)). L'initialisation repose sur une technique \"butterfly\" (aller-retour autour du temps initial). ","category":"page"},{"location":"docfr/#Initialisation","page":"HiOscSolver.jl","title":"Initialisation","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Soit r l'ordre de la méthode AB_r. Soit Delta t le pas de temps, pour i in  -r -(r-1) ldots r-1 r, nous notons u_i = u(t_0+i Delta t). Soit r les ordres des méthodes AB intermédiaires que nous allons utiliser. Si u_k est connue avec une précision de mathcalO(Delta t^r+1), et pour r geq 2 u_k-1 ldots u_k-r+1 sont connues avec une précision mathcalO(Delta t^r) alors on peut calculer u_k+1 avec une précision de mathcalO(Delta t^r+1) avec la méthode AB_r De même, si u_k est connue avec une précision de mathcalO(Delta t^r+1), et pour r geq 2 u_k+1 ldots u_k+r-1 sont connues avec une précision mathcalO(Delta t^r) alors on peut calculer u_k-1 avec une précision de mathcalO(Delta t^r+1) avec la méthode AB_r.","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"# #### Algorithme(old)\n# Notons que, dans l'algorithme qui suit, l'ordre 2 est détaillé pour faciliter la compréhension, cet ordre aurait pu entrer dans le cadre général.\n# - Avec la méthode $AB_1$, à partir de $u_0$ on calcule $u_1$ avec une précision de $\\mathcal{O}(\\Delta t^2)$\n# - Avec la méthode $AB_2$, à partir de $u_0$ et $u_1$, on calcule $u_{-1}$ avec une précision de $\\mathcal{O}(\\Delta t^3)$\n# - Avec la méthode $AB_2$, à partir de $u_0$ et $u_{-1}$, on calcule $u_{1}$ avec une précision de $\\mathcal{O}(\\Delta t^3)$\n# - Avec la méthode $AB_2$,  à partir de $u_1$ et $u_0$, on calcule $u_{2}$ avec une précision de $\\mathcal{O}(\\Delta t^3)$\n# - Pour $r' = 3$ à $r' = r$\n#     - Pour $k=1$ à $k=r'-1$\n#         - Avec la méthode $AB_{r'}$, à partir de $u_{1-k}, u_{2-k}, \\ldots,u_{r'-k}$, on calcule $u_{-k}$ avec une précision de $\\mathcal{O}(\\Delta t^{r'+1})$\n#     - Pour $k=1$ à $k=r'$\n#          - Avec la méthode $AB_{r'}$, à partir de $u_{k-1}, u_{k-2}, \\ldots,u_{k-r}$, on calcule $u_{k}$ avec une précision de $\\mathcal{O}(\\Delta t^{r'+1})$\n# \n# A la fin de cet algorithme, les valeurs $u_1, \\ldots u_r$ sont connues avec une précision de $\\mathcal{O}(\\Delta t^{r+1})$, nous avons même une valeur de plus que nécessaire pour lancer l'algorithme $AB_r$.\n# -->","category":"page"},{"location":"docfr/#Algorithme","page":"HiOscSolver.jl","title":"Algorithme","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Avec la méthode AB_1, à partir de u_0 on calcule u_-1 avec une précision de mathcalO(Delta t^2)\nAvec la méthode AB_2, à partir de u_0 et u_-1, on calcule u_1 avec une précision de mathcalO(Delta t^3)\nPour r = 3 à r = r\nPour k=1 à k=r-1\nAvec la méthode AB_r-1, à partir de u_1-k u_2-k ldotsu_r-1-k, on calcule u_-k avec une précision de mathcalO(Delta t^r)\nPour k=1 à k=r-1\nAvec la méthode AB_r, à partir de u_k-1 u_k-2 ldotsu_k-r, on calcule u_k avec une précision de mathcalO(Delta t^r+1)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A la fin de cet algorithme, les valeurs u_0 u_1 ldots u_r-1 sont connues avec une précision de mathcalO(Delta t^r+1), nous pouvons lancer l'algorithme AB_r.","category":"page"},{"location":"docfr/#La-méthode-Adams-Bashforth","page":"HiOscSolver.jl","title":"La méthode Adams-Bashforth","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Pour une méthode d'Adams-Bashforth d'ordre r en temps et spectral en tau, on introduit tout d'abord un maillage dans la direction tau  tau_ell = ell Delta tau  ell=0 dots N_tau avec Deltatau=2piN_tau, N_tau étant le nombre de points de discrétisation. Si on applique la transformée de Fourier à l'équation double-échelle, on obtient ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracpartial hatU_ellpartial t + fraciellvarepsilonhatU_ell = hatF_ell(t) qquad ell=-N_tau2 dots N_tau2-1 ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"avec ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"U(t tau) = sum_ell=-N_tau2^N_tau2-1 hatU_ell(t) e^ielltau qquad F(tau U(t tau)) = sum_ell=-N_tau2^N_tau2-1 hatF_ell(t) e^ielltau ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Si on souhaite calculer hatF à partir de hatU nous avons la formule <font color=red> à vérifier</font>","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"hatF_ell(t) = sum_r=-N_tau2^N_tau2-1 e^- fracpi i r ellN_tau  e^fracellvarepsilon A F( t frace^-fracellvarepsilon AN_tausum_k=-N_tau2^N_tau2-1 e^fracpi i k ellN_tau hatU_k(t))","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Maintenant, étant donné un pas de temps Delta t0 et une discrétisation en temps t_n=nDelta t, on peut écrire la formule de Duhamel suivante (n geq 0)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"hatU_ell(t_n+1) \n= e^-iellDelta tvarepsilonhatU_ell(t_n)  + int_0^Delta t e^-iell(Delta t -s)varepsilon hatF_ell(t_n+s)ds ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Ainsi, pour obtenir un schéma d'ordre (r+1), on  approche la fonction hatF_ell(t_n+s) par le polynôme de Lagrange d'ordre r interpolateur aux points t_n-j j=0 dots r. Ce polynôme s'écrit ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"hatF_ell(t_n+s) approx sum_k=0^r Big(Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta t Big) hatF_ell(t_n-t_j)  ngeq 0  ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Ainsi, à partir de cette approximation, on intègre exactement, ce qui demande les formules suivantes ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"p^r_ell j = int_0^Delta te^-iell(Delta t -s)varepsilonBig( Pi_j=0 jneq k^r fracs+j Delta t(j-k)Delta tBig) ds   ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"pour chaque j et ell tels que 0leq jleq r  ell=-N_tau2 dots N_tau2-1. Ces coefficients p^r_ell j peuvent être pré-calculés et stockés une fois pour toute. Ainsi, le schéma s'écrit finalement ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"hatU_ell^n+1= e^-iellDelta tvarepsilonhatU_ell^n + sum_j=0^r p^r_ell j hatF_ell^n-j  ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"avec hatU_ell^n approx hatU_ell(t_n) et hatF_ell^n-japprox hatF_ell(t_n-j). ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On peut vérifier que l'erreur de troncature de ce schéma est mathcalO(Delta t^r+1), une fois que les valeurs initiales hatU_ell^1 dots hatU_ell^r ont été calculées.  ","category":"page"},{"location":"docfr/#Cas-non-homogène-f(u,-t)","page":"HiOscSolver.jl","title":"Cas non-homogène f(u t)","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On considère ici le cas où f dépend de la variable t","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd u(t)dt = frac1varepsilon A u(t) + f(u(t) t)  u(t=t_0)=u_0  varepsilonin 0 1 \ntageq1_t","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Le cas non-homogène \\ref{eq1t} entre dans le cadre \\eqref{eq1}  en introduisant la variable \\theta : t \\in [t{0}, t{fin}] \\mapsto \\theta(t) = t\\in \\mathbb{R}$  qui permet de reformuler le cas non-homogène \\eqref{eq1t} en un problème homogène de la forme \\eqref{eq1}.  En effet, on reformule \\eqref{eq1_t} de la manière suivante ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"beginaligned\nfracd u(t) dt   = frac1varepsilon Au(t) + f(u(t) theta(t)) \nfracd theta(t) dt   = 1\nendaligned\nlabeleq1_t_theta","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"avec la condition initiale u(t_0)=u_0 theta(t_0)=t_0. Ainsi, le problème \\eqref{eq1ttheta} se réécrit en une équation satisfaite par y tin t_0 t_fin mapsto y(t) =(u(t) theta(t))in mathbbR^n+1","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd ydt = frac1varepsilon tildeA y + g(y)  y(t_0)=(u_0 t_0) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"avec tildeAin mathcalM_n+1 n+1(mathbbR)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"tildeA=\nleft(\nbeginarraycccc\n             0 \n    A       0 \n            0 \n0  0  0   0 \nendarray\nright) qquad qquad\ng(y)=g(u theta) = left(\nbeginarraycccccc\nf(u theta) \n1\nendarray\nright) in mathbbR^n+1 ","category":"page"},{"location":"docfr/#La-méthode-Runge-Kutta-\"classique\"-(ordre-4)-adaptée-à-l'exponentielle","page":"HiOscSolver.jl","title":"La méthode Runge-Kutta \"classique\" (ordre 4) adaptée à l'exponentielle","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Notations : ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Nous notons G la fonction qui permet de passer de hatU à hatf, ainsi hatf = G(hatU).\nNous notons S_t_0^t_1(t_2ell) l'intégrale S_t_0^t_1(t_2ell) = int_t_0^t_1 e^- i ell (t_2 - s)varepsilon ds = ( i varepsilon  ell) ( e^- i ell (t_2 - t_1)varepsilon-e^- i ell (t_2 - t_0)varepsilon)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Voici les calculs:","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"u_1ell = hatU_n ell\nu_2ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell ) G_ell(u_1)\nu_3ell = e^- i ell h_n (2 varepsilon)hatU_n ell + S_0^h_n 2 ( h_n 2ell )  G_ell(u_2)\nD'après (28) du papier, avec c=-i ell h_n varepsilon, on a   \nu_4ell = e^- i ell h_n (2varepsilon)u_2ell + S_0^h_n2 ( h_n2ell ) 2 G_ell(u_3)-G_ell(u_1)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"hatU_n+1 ell = e^- i ell h_n varepsilonhatU_n ell + S_0^h_n6 ( h_nell ) G_ell(u_1) + frac12 S_h_n6^5 h_n6 ( h_nell ) ( G_ell(u_2) + G_ell(u_3) ) + S_5h_n6^ h_n ( h_nell ) G_ell(u_4)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"D'après (29) du papier, avec c=-i ell h_n varepsilon, on a","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"hatU_n+1 ell = e^- i ell h_n varepsilonhatU_n ell +  G_ell(u_1) -4+i ell h_n varepsilon + e^-i ell h_n varepsilon(4+3i ell h_n varepsilon+(i ell h_n varepsilon)^2+ (2 G_ell(u_2) + G_ell(u_3) )-2-i ell h_n varepsilon+e^-i ell h_n varepsilon(2-i ell h_n varepsilon) + G_ell(u_4)-4+3i ell h_n varepsilon -(i ell h_n varepsilon)^2 + e^-i ell h_n varepsilon(4+i ell h_n varepsilon)(h_n^2 (i ell h_n varepsilon)^3)","category":"page"},{"location":"docfr/#Utilisation","page":"HiOscSolver.jl","title":"Utilisation","text":"","category":"section"},{"location":"docfr/#Paramètres-d'entrée","page":"HiOscSolver.jl","title":"Paramètres d'entrée","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Les arguments d'entrée utilisent le même format que le package ODE. ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Ainsi, dans un premier temps, il faut définir les arguments nécessaires pour construire le problème  \\eqref{eq1}, à savoir","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"la fonction f (sous la forme Julia) \nla condition initiale u_0\nles temps initial t_0 et final t_fin \nle deuxième paramètre de la fonction \nla matrice A \nvarepsilon in 0 1","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"\nusing HiOscSolver\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nfct = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] \nepsilon= 0.0001\nt_min=0.0\nt_max=3.0\nu0 = [0.55, 0.12, 0.03, 0.89]\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon) \n","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A partir du problème prob, on peut maintenant passer à sa résolution numérique.  Pour cela, on définit les paramètres numériques ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"le nombre de tranches de temps N_t qui définit le pas de temps Delta t = fract_0-t_finN_t \nl'ordre r de la méthode \nle nombre de points N_tau dans la direction tau \nl'ordre de la préparation q de la condition initiale \nprécision  <font color=red> non encore implémentée</font>. ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Par défaut, les paramètres sont : N_t=100, r=4, N_tau=32 et q=r+2=6 Pour résoudre le problème avec les paramètres par défaut, il suffit d'appeler la commande solve avec le problème déjà défini comme paramètre","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"sol = solve(prob); ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Ce qui est équivalent à cet appel ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"sol = solve(\n    prob;\n    nb_tau=32, \n    order=4, \n    order_prep=order+2,\n    dense=true, \n    nb_t=100, \n    getprecision=dense, \n    verbose=100,    \n    par_u0=missing,\n    p_coef=missing,\n) ","category":"page"},{"location":"docfr/#Définition-exhaustive-des-paramètres","page":"HiOscSolver.jl","title":"Définition exhaustive des paramètres","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"prob : problème défini par HiOscODEProblem \nnb_tau=32 : N_tau\norder=4 : ordre r de la méthode\norder_prep=order+2 : ordre de préparation des données initiales\ndense=true : indique si l'on conserve ou non les données issues de la transformée de fourier, si dense=false, le traitement est plus rapide mais l'interpolation ne peut plus être faite.\nnb_t=100 : N_t\ngetprecision=dense : indique si la précision est calculée, la méthode utilisée pour calculer la précision multiplie par 2 le temps de traitement.\nverbose=100 : niveau de trace, si verbose=0 alors rien n'est affiché.\npar_u0 : données initiales préparées, si on doit faire plusieurs appels à solve avec les mêmes données initiales et au même ordre on peut passer en paramêtre les données déjà calculées.\np_coef : tableau avec les coefficients de la méthode Adams-Bashforth. Ce tableau peut être utilisé pour optimiser plusieurs appels avec les mêmes paramètres. ","category":"page"},{"location":"docfr/#Arguments-de-sortie","page":"HiOscSolver.jl","title":"Arguments de sortie","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"En sortie, une structure de type HiOscODESolution. Cette structure peut être vue comme une fonction de t, elle peut aussi être vue comme un tableau de taille N_t + 1. Cette structure contient aussi les champs absprec et relprec qui sont les précisions, respectivement absolue et relative, calculées.","category":"page"},{"location":"docfr/#Exemple","page":"HiOscSolver.jl","title":"Exemple","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"using HiOscSolver \nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0] \nfct = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ]\nepsilon= 0.0001 \nt_min=0.0 \nt_max=3.0\nu0 = [0.55, 0.12, 0.03, 0.89] \nprob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"sol = solve(prob);\nt=2.541451547\nsol(t)\nsol[end]\nsol(3.0)\nsol.absprec\nsol.relprec","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Pour visualiser le résultat, on peut aussi utiliser Plot, par exemple","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"using Plots\nplot(sol) ","category":"page"},{"location":"docfr/#Exemples","page":"HiOscSolver.jl","title":"Exemples","text":"","category":"section"},{"location":"docfr/#Hénon-Heiles","page":"HiOscSolver.jl","title":"Hénon-Heiles","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On considère le système de Hénon-Heiles satisfait par u(t)=(u_1 u_2 u_3 u_4)(t) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd u dt = frac1varepsilon Au + f(u)  u(0)=u_0inmathbbR^4 ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"où A et f sont choisis comme suit ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright) qquad qquad\nf(u) = left(\nbeginarraycccc\n0 \nu_4\n-2 u_1 u_2\n-u_2-u_1^2+u_2^2\nendarray\nright) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"on choisit par exemple, varepsilon=0001 et u_0 = (012 012 012 012)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"using HiOscSolver\nusing Plots","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A=[0 0 1 0 ; \n   0 0 0 0 ; \n  -1 0 0 0 ; \n   0 0 0 0]\nfct = (u,p,t) ->  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] \nepsilon= 0.001\nt_min=0.0\nt_max=1.0\nu0 = [0.12, 0.12, 0.12, 0.12]\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon)\nsol = solve(prob);\nplot(sol)","category":"page"},{"location":"docfr/#Particule-chargée","page":"HiOscSolver.jl","title":"Particule chargée","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On considère un système de particules chargées sous l'effet d'un champ électro-magnétique extérieur  (E(t x) B(t x))in mathbbR^6. Les particules sont décrites de manière dynamique par leur position  x(t)inmathbbR^3 et leur vitesse v(t)inmathbbR^3. On indexera par  i  la i-ème composante d'un vecteur. Les équations de Newton appliquées à une particule s'écrivent  ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"beginaligned\nfracd x(t) dt= v(t) \nfracd v(t) dt= fracem leftE(t x(t)) + v(t)times B(t x(t))right \nendaligned","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On va supposer que le champ magnétique s'écrit B(t x)=(0 0 1)^T et sous un certain scaling, on considère l'équation  suivante ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"beginaligned\nfracd x_1(t) dt = frac1varepsilonv_1(t) \nfracd x_2(t) dt = frac1varepsilon v_2(t) \nfracd x_3(t) dt = v_3(t) \nfracd v_1(t) dt = E_1(t x(t)) + frac1varepsilonv_2(t)\nfracd v_2(t) dt = E_2(t x(t)) - frac1varepsilonv_1(t)\nfracd v_3(t) dt = E_3(t x(t)) \nendaligned","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"ce qui se réécrit sous la forme suivante ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd u(t) dt= frac1varepsilonA u(t) + F(t u(t)) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"où le vecteur inconnu u(t)=(x(t) v(t))inmathbbR^6, A est une matrice carrée de taille 6times 6  et F est une fonction à valeur dans mathbbR^6. A et F sont données par ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A=\nleft(\nbeginarraycccccc\n0  0  0  1  0  0 \n0  0  0  0  1  0 \n0  0  0  0  0  0 \n0  0  0  0  1  0 \n0  0  0  -1  0  0 \n0  0  0  0  0  0 \nendarray\nright) qquad qquad\nF(t u(t)) = left(\nbeginarraycccccc\n0 \n0\nu_6(t)\nE_1(t u_1(t) u_2(t) u_3(t))\nE_2(t  u_1(t) u_2(t) u_3(t)\nE_3(t  u_1(t) u_2(t) u_3(t)\nendarray\nright) ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On peut considérer la fonction E=(E_1 E_2 E_3) suivante ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"E(t x) =\nleft(\nbeginarrayccc\ncos(x_12)sin(x_2)sin(x_3)2\nsin(x_12)cos(x_2)sin(x_3)\nsin(x_12)sin(x_2)cos(x_3)\nendarray\nright)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"using HiOscSolver\nusing Plots","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A = [0 0 0 1 0 0; 0 0 0 0 1 0;0 0 0 0 0 0; 0 0 0 0 1 0; 0 0 0 -1 0 0; 0 0 0 0 0 0]\nfunction fparticle(u, p, t)\n    s1, c1 = sincos(u[1]/2)\n    s2, c2 = sincos(u[2])\n    s3, c3 = sincos(u[3])\n    return [0, 0, u[6], c1*s2*s3/2, s1*c2*s3, s1*s2*c3]\nend\nepsilon= 0.05\nt_min=0.0\nt_max=1.0\nu0 = [1.0, 1.5, -0.5, 0, -1.2, 0.8]\nprob = HiOscODEProblem(fparticle, u0, (t_min,t_max), missing, A, epsilon)\nsol=solve(prob)\nplot(sol)","category":"page"},{"location":"docfr/#Cas-non-homogène-linéaire","page":"HiOscSolver.jl","title":"Cas non-homogène linéaire","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"On considère le système linéaire non-homogène suivant satisfait par u(t)=(u_1 u_2 u_3 u_4)(t)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd u dt = frac1varepsilon Au + f(t u)  u(0)=u_0inmathbbR^4 ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"où A et f sont choisis comme suit ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A=\nleft(\nbeginarraycccc\n0  0  1  0  \n0  0  0  0  \n-1  0  0  0  \n0  0  0  0  \nendarray\nright) qquad qquad\nf(t u) = Bu +alpha t +beta qquad qquad\nBin mathcalM_4 4(mathbbR) alpha beta in mathbbR^4 ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"B alpha beta","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"sont choisis aléatoirement. Nous souhaitons obtenir une grande précision, nous allons donc utiliser des réel de type BigFloat, il sont codés sur 256 bits par défaut ce qui donne une borne de précision d'environ 2^-256 approx 10^-77.  Nous comparons à la fin un résultat calculé avec un résultat exact. ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"\nusing HiOscSolver\nusing Plots\nusing Random\n\nRandom.seed!(1111)\n\nA=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]\nB = 2rand(BigFloat, 4, 4) - ones(BigFloat, 4, 4)\nalpha = 2rand(BigFloat, 4) - ones(BigFloat, 4)\nbeta = 2rand(BigFloat, 4) - ones(BigFloat, 4)\nfct = (u,p,t)-> B*u + t*p[1] +p[2]\nu0 = [big\"0.5\", big\"-0.123\", big\"0.8\", big\"0.7\"]\nt_min=big\"0.0\"\nt_max=big\"1.0\"\nepsilon=big\"0.017\"\nprob = HiOscODEProblem(fct, u0, (t_min,t_max), (alpha, beta), A, epsilon, B)\nsol = solve(prob, nb_t=10000, order=8)\nsol.absprec\nt=big\"0.9756534187771\"\nsol(t)-getexactsol(sol.par_u0.parphi, u0, t)\nplot(sol.t,sol.u_tr)","category":"page"},{"location":"docfr/#Calcul-de-la-solution-exacte","page":"HiOscSolver.jl","title":"Calcul de la solution exacte","text":"","category":"section"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Il s'agit de calculer la solution exacte u(t) de l'équation suivante à l'instant t","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"fracd u dt = frac1varepsilon Au + Bu +alpha t +beta  u(0)=u_0inmathbbR^4","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"A","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"et B sont définies plus haut.","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Soit M = frac1varepsilon A + B","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"C = e^-t_0 Mu_0 +M^-1 e^-t_0 M (t_0alpha+beta)+ M^-2 e^-t_0 M alpha","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"C_t = -M^-1 e^-t M (talpha+beta)-M^-2 e^-t M alpha","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"u(t) = e^t M ( C + C_t)","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"Ce qui, traduit en langage Julia, donne le code de la fonction getexactsol : ","category":"page"},{"location":"docfr/","page":"HiOscSolver.jl","title":"HiOscSolver.jl","text":"function getexactsol(par::PreparePhi, u0, t)\n    @assert !ismissing(par.matrix_B) \"The debug matrix is not defined\"\n    sparse_A = par.sparse_Ap[1:(end-1),1:(end-1)]\n    m = (1/par.epsilon)*sparse_A+par.matrix_B\n    t0 = par.t_0\n    if ismissing(par.paramfct)\n        return exp((t-t0)*m)*u0\n    end\n    a, b = par.paramfct\n    mm1 = m^(-1)\n    mm2 = mm1^2\n    e_t0 = exp(-t0*m)\n    C = e_t0*u0 + mm1*e_t0*(t0*a+b)+mm2*e_t0*a\n    e_inv = exp(-t*m)\n    e = exp(t*m)\n    C_t = -mm1*e_inv*(t*a+b)-mm2*e_inv*a\n    return e*C+e*C_t\nend\n","category":"page"},{"location":"#HiOscSolver.jl","page":"Documentation","title":"HiOscSolver.jl","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"The objective of this Julia package is to valorize the recent developments carried out within MINGuS on Uniformly Accurate numerical methods (UA) for highly oscillating problems. We propose to solve the following equation ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"fracd u(t)dt = frac1varepsilon A u(t) + f(u(t))  u(t=t_0)=u_0  varepsilonin 0 1  (1)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"with ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"u  tin t_0 t_fin mapsto u(t)in mathbbR^n  t_0 t_textendin mathbbR, \nu_0in mathbbR^n, \nAin mathcalM_nn(mathbbR) is such that tau mapsto exp(tau A) is periodic,  \nf  uin  mathbbR^n mapsto mathbbR^n.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"The purpose here is to write an explanatory documentation of the Julia package containing the two-scale method (see Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020), Philippe Chartier , Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2015) and Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2013). This package is inspired by the Differential Equations package SciML.","category":"page"},{"location":"#References","page":"Documentation","title":"References","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [HiOscSolver]\nOrder   = [:type]","category":"page"},{"location":"types/#HiOscSolver.PolyExp","page":"Types","title":"HiOscSolver.PolyExp","text":"PolyExp(p::Vector{T}, a::T, b::T)\nPolyExp(pol::Polynomial{T},a::T,b::T)\n\nOn the model of Polynomial from package Polynomials, construct a function that is a polynome multiply by an exponential function. The exponential is an exponential of an affine function a x + b. The polynome is construct from its coefficients p, lowest order first.\n\nIf f = (p_n x^n + ldots + p_2 x^2 + p_1 x + p_0)e^a x + b, we construct this through PolyExp([p_0, p_1, ..., p_n], a, b).  It is also possible to construct it directly from the polynome.\n\nIn the sequels some methods with the same name than for Polynomial are implemented (derivative, integrate, strings, ...) but not all, only the methods needed are developped.\n\nArguments :\n\np::Vector{T} or pol::Polynomial{T} : vector of coefficients of the polynome, or directly the polynome.\na::T, b::T : coefficients of affine exponentiated function.\n\nExamples\n\njulia> pe=PolyExp([1,2,3],2,1)\nPolyExp(Polynomial(1 + 2*x + 3*x^2)*exp(2*x + 1))\n\njulia> pe(0)\n2.718281828459045\n\njulia> pe(1)\n120.51322153912601\n\n\n\n\n\n","category":"type"},{"location":"types/#HiOscSolver.PrepareFftBig","page":"Types","title":"HiOscSolver.PrepareFftBig","text":"PrepareFftBig( size_fft::Unsigned, [T=BigFloat])\n\nImmutable structure to operate fft transform,  x is the type of non transformed data also called signal.\n\nArguments :\n\nsize_fft::Integer : Number of values, must be a power of two\n[T=BigFloat | x::T ] : type of the values\n\nImplementation\n\nsize_fft : size of the signal\ntab_permut : permutation\nroot_one : size order roots of one\nrootoneconj : conjugate of root_one\n\n\n\n\n\n","category":"type"},{"location":"types/#HiOscSolver.PreparePhi","page":"Types","title":"HiOscSolver.PreparePhi","text":"PreparePhi(n_tau::Integer, epsilon::AbstractFloat, matrix_A::Matrix{Number},\nfct::Function, [matrix_B::Matrix])\n\nImmutable structure, to share calculations, needed for the phi function. These data can be used elsewhere for example in twoscale function.\n\nArguments :\n\nn_tau::Integer : number of value around the unit disk, it must be a power of two.\nepsilon::AbstractFloat : epsilon of the system, the type of this value will be the typeof the result.\nmatrix_A::Matrix{Number} : Matrix of twoscale system\nfct::Function : function of the system\n[matrix_B::Matrix] : matrix representing the linear function for debug\n\nKeywords\n\nmode=1 : possibility of addionnal modes for optional behavior\nparamfct=missing : middle parameter of function fct\nt_0=zero(epsilon) : beginning of the time\n\nFields :\n\nepsilon : epsilon of the system.\nn_tau : number of values for fft\ntau_list : list of values around the unit disk (0 ... ntau/2 -ntau/2-1 ... -1 )\ntau_int : list of values to integrate FFT\nmatrix_Ap : sparse matrix with time dimension\ntau_Ap : for each angular tau around the unit disk the matrix e^(tau time Ap)\ntau_Ap_inv : inverse of tau_Ap\npar_fft : fft parameters\nfct : function of differential equation\nparamfct : middle parameter of function fct\nsize_vect : size of vector that is the size of the matrix\nmatrix_B : B matrix for the linear case\nmode : for optional behavior\nt_0 : beginning of the time\n\n\n\n\n\n","category":"type"},{"location":"types/#HiOscSolver.PrepareTwoScalesPureAB","page":"Types","title":"HiOscSolver.PrepareTwoScalesPureAB","text":"PrepareTwoScalesPureAB(nb_t, t_max, order, par_u0::PrepareU0)\n\nImmutable structure, to share calculations, needed for the twoscale function\n\nArguments :\n\nnb_t::Int : number of time slices\nt_max: end of the time\norder : order for compute the coefficients\npar_u0::PrepareU0 : prepared initial data\n\nKeywords :\n\np_coef::Union{CoefExpAB,Missing}=missing : precomputed coefficients of AB method \nverbose=100 : trace level\n\nFields :\n\nnb_t : number of time slices\nt_max : end of the time\norder : order for compute the coefficients\nparphi : prepared parameters for phi (from par_u0)\npar_u0 : prepared initial data\np_coef : computed coefficients\nexptau : exp( -imdt'\tau'/epsilon) for all '\tau' values\nexptau_inv : inverse of exptau\nverbose : trace level\n\n\n\n\n\n","category":"type"},{"location":"types/#HiOscSolver.PrepareU0","page":"Types","title":"HiOscSolver.PrepareU0","text":"PrepareU0(parphi::PreparePhi, order, u0, newprec)\n\nPreparation of the original data\n\nArguments\n\nparphi::PreparePhi : phi prepared parameters\norder : order of the preparation\nu0 : initial data\n[newprec] : precision for the compute, if no given a default value is computed as a function of epsilon\n\nFields\n\nparphi : phi prepared parameters\norder : order of the preparation\nut0 : formated initial data\nu0 :initial data\n\n\n\n\n\n","category":"type"}]
}
