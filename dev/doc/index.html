<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical method · HiOscSolver.jl</title><link rel="canonical" href="https://ymocquar.github.io/HiOscSolver.jl/doc/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="HiOscSolver.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">HiOscSolver.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Documentation</a></li><li><a class="tocitem" href="../numerical_method/">Numerical Method</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../charged_particle/">Charged Particle</a></li><li><a class="tocitem" href="../henon_heiles/">Henon-Heiles</a></li><li><a class="tocitem" href="../future_work/">Future work</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical method</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical method</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ymocquar/HiOscSolver.jl/blob/master/docs/src/doc.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-method"><a class="docs-heading-anchor" href="#Numerical-method">Numerical method</a><a id="Numerical-method-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-method" title="Permalink"></a></h1><h2 id="Two-scale-formulation"><a class="docs-heading-anchor" href="#Two-scale-formulation">Two-scale formulation</a><a id="Two-scale-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Two-scale-formulation" title="Permalink"></a></h2><p>First, rewrite equation (1) using the variable change <span>$w(t)=\exp(-(t-t_{0})A/\varepsilon) u(t)$</span> to obtain</p><p class="math-container">\[\frac{d w(t)}{dt} = F\Big( \frac{t-t_{0}}{\varepsilon}, w(t) \Big), \;\;\; w(t_{0})=u_{0}, \;\; \varepsilon\in ]0, 1],\]</p><p>where the function <span>$F$</span> is expressed from the data of the original problem (1)</p><p class="math-container">\[F\Big( \frac{s}{\varepsilon}, w \Big) = \exp(-sA/\varepsilon) \; f( \exp(sA/\varepsilon), \; w).\]</p><p>We then introduce the function <span>$U(t, \tau), \tau\in [0, 2 \pi]$</span> such that <span>$U(t, \tau=(t-t_{0})/\varepsilon) = w(t)$</span>. The two-scale function is then the solution of the following equation</p><p class="math-container">\[\frac{\partial U}{\partial t} + \frac{1}{\varepsilon} \frac{\partial U}{\partial \tau} =  F( \tau, U), \;\;\; U(t=t_{0}, \tau)=\Phi(\tau), \;\; \varepsilon\in ]0, 1], \;\;\;\;\;\;\;\;\;\; (2)\]</p><p>where <span>$\Phi$</span> is a function checking <span>$\Phi(\tau=0)=u_{0}$</span> chosen so that the <span>$U$</span> solution of (2) is regular (see <a href="../#chartier2015">Philippe Chartier , Nicolas Crouseilles , Mohammed Lemou , Florian Méhats  (2015)</a> and <a href="../#chartier2020">Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020)</a>.</p><h2 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h2><p>The numerical method is based on a suitable time discretization of equation (2). In the direction <span>$\tau$</span>, a spectral method is used, while for the time <span>$t$</span>, an exponential Adams-Bashforth method allows to build a high order method (see <a href="../#chartier2020">Philippe Chartier , Mohammed Lemou , Florian Méhats , Xiaofei Zhao  (2020)</a>). The suitable choice of the initial condition is required to ensure high order accuracy. From a numerical point of view, a &quot;butterfly&quot; technique is introduced here (going back and forth around the initial time).</p><h3 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h3><p>Let r be the order of the method <span>$AB_r$</span>.<br/>Let <span>$\Delta t$</span> the time step, for <span>$i \in \{r, -(r-1), \ldots, r-1, r\}$</span>, we note <span>$u_i = u(t_0+i \Delta t)$</span>.<br/>Let <span>$r&#39;$</span> be the orders of the intermediate AB methods we will use.<br/>If <span>$u_{k}$</span> is known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span>, and for <span>$r&#39; \geq 2, u_{k-1}, \ldots, u_{k-r&#39;+1}$</span> are known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;})$</span> then we can calculate <span>$u_{k+1}$</span> with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span> with the method <span>$AB_{r&#39;}$</span>.<br/>Similarly, if <span>$u_{k}$</span> is known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span>, and for <span>$r&#39; \geq 2, u_{k+1}, \ldots, u_{k+r&#39;-1}$</span> are known with a precision of <span>${\mathcal O}(\Delta t^{r&#39;})$</span> then we can calculate <span>$u_{k-1}$</span> with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span> with the method <span>$AB_{r&#39;}$</span>.</p><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><ul><li>With the method <span>$AB_1$</span>, from <span>$u_0$</span> we calculate <span>$u_{-1}$</span> with a precision of <span>${\mathcal O}(\Delta t^2)$</span></li><li>With the method <span>$AB_2$</span>, starting from <span>$u_{0}$</span> and <span>$u_{-1}$</span>, we calculate <span>$u_{1}$</span> with a precision of <span>${\mathcal O}(\Delta t^3)$</span></li><li>For <span>$r&#39; = $3 to $r&#39; = r$</span>.<ul><li>For <span>$k=1$</span> to <span>$k=r&#39;-1$</span><ul><li>With the method <span>$AB_{r&#39;-1}$</span>, from <span>$u_{1-k}, u_{2-k}, \ldots,u_{r&#39;-1-k}$</span>, we calculate <span>$u_{-k}$</span> with a precision of <span>${\cal O}(\Delta t^{r&#39;})$</span></li></ul></li><li>For <span>$k=1$</span> to <span>$k=r&#39;-1$</span><ul><li>With the method <span>$AB_{r&#39;}$</span>, from <span>$u_{k-1}, u_{k-2}, \ldots,u_{k-r&#39;}$</span>, we calculate <span>$u_{k}$</span> with a precision of <span>${\mathcal O}(\Delta t^{r&#39;+1})$</span></li></ul></li></ul></li></ul><p>At the end of this algorithm, the values <span>$u_0, u_1, \ldots u_{r-1}$</span> are known with a precision of <span>${\mathcal O}(\Delta t^{r+1})$</span>, we can launch the algorithm <span>$AB_r$</span>.</p><h3 id="The-Adams-Bashforth-Method"><a class="docs-heading-anchor" href="#The-Adams-Bashforth-Method">The Adams-Bashforth Method</a><a id="The-Adams-Bashforth-Method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Adams-Bashforth-Method" title="Permalink"></a></h3><p>For an Adams-Bashforth method of order <span>$r$</span> in time and spectral <span>$\tau$</span>, we first introduce a mesh in the <span>$\tau$</span> direction.<br/><span>$\tau_{\ell} = \ell \Delta \tau, \ell = 0, \ldots, N_{\tau}-1$</span>. Where <span>$N_{\tau}$</span> is the number of points of discretization. If we apply the Fourier transform to the two-scale equation, we obtain </p><p class="math-container">\[\frac{\partial \hat{U}_\ell}{\partial t} + \frac{i\ell}{\varepsilon}\hat{U}_\ell = \hat{F}_\ell(t), \;\; \ell=-N_\tau/2, \dots, N_\tau/2-1,\]</p><p>with</p><p class="math-container">\[U(t, \tau_k) = \sum_{\ell=-N_{\tau}/2}^{N_{\tau}/2-1} \hat{U}_{\ell}(t) e^{i\ell k 2\pi/N_{\tau}} \;\;\; \text{ and } F(\tau_k, U(t, \tau_k)) = \sum_{\ell=-N_{\tau}/2}^{N_{\tau}/2-1} \hat{F}_{\ell}(t) e^{i\ell k 2\pi/N_\tau}.\]</p><p>and the inverse (discrete) Fourier transform formulae</p><p class="math-container">\[\hat{U}_{\ell}(t) = \frac{1}{N_{\tau}}\sum_{k=0}^{N_{\tau}-1} U(t, \tau_k) e^{-i\ell k 2\pi/N_{\tau}}\;\;\; \text{ and } \hat{F}_{\ell}(t) = \frac{1}{N_{\tau}}\sum_{k=0}^{N_{\tau}-1} F(\tau_k, U(t, \tau_k))e^{-i\ell k 2\pi/N_{\tau}}.\]</p><p>If we wish to calculate <span>$\hat{F}_{\ell}$</span> from <span>$\hat{U}_{\ell}$</span> we have the following formula </p><p class="math-container">\[F(\tau_k,U(t, \tau_k)) = e^{-\tau_k A}f(e^{\tau_k A}U(t, \tau_k)) \;\;\]</p><p>from which the Fourier transform is calculated in <span>$\tau$</span> from the discrete Fourier transform formulas above.</p><p>Now, given a time step <span>$\Delta t&gt;0$</span> and a discretization in time <span>$t_n=n\Delta t$</span>, we can write the following Duhamel formula (<span>$n\geq 0$</span>)</p><p class="math-container">\[\hat{U}_{\ell}(t_{n+1}) 
= e^{-i\ell\Delta t/\varepsilon}\hat{U}_{\ell}(t_{n})  + \int_0^{\Delta t} e^{-i\ell(\Delta t -s)/\varepsilon} \hat{F}_\ell(t_n+s)ds.\]</p><p>Thus, to obtain a <span>$(r+1)$</span> scheme, we can  approaches the function <span>$\hat{F}_\ell(t_n+s)$</span> by the Lagrange polynomial of order <span>$r$</span> interpolator at points <span>$t_{n-j}, j=0, \dots, r$</span>. This polynomial is written </p><p class="math-container">\[\hat{F}_\ell(t_n+s) \approx \sum_{k=0}^r \Big(\Pi_{j=0, j\neq k}^r \frac{s+j \Delta t}{(j-k)\Delta t} \Big) \hat{F}_\ell(t_n-t_j), \;\; n\geq 0.\]</p><p>Thus, from this approximation, we integrate exactly, which requires the following formulas</p><p class="math-container">\[p^{[r]}_{\ell, j} = \int_0^{\Delta t}e^{-i\ell(\Delta t -s)/\varepsilon}\Big( \Pi_{j=0, j\neq k}^r \frac{s+j \Delta t}{(j-k)\Delta t}\Big) ds,\]</p><p>for each <span>$j$</span> and <span>$\ell$</span> such that <span>$0\leq j\leq r, \; \ell=-N_\tau/2, \dots, N_\tau/2-1$</span>. These coefficients <span>$p^{[r]}_{\ell, j}$</span> can be pre-calculated and stored once and for all. Thus, the schema is finally written</p><p class="math-container">\[\hat{U}_{\ell}^{n+1}= e^{-i\ell\Delta t/\varepsilon}\hat{U}_{\ell}^n + \sum_{j=0}^r p^{[r]}_{\ell, j} \hat{F}_\ell^{n-j},\]</p><p>with <span>$\hat{U}_{\ell}^n \approx \hat{U}_{\ell}(t_n)$</span> and <span>$\hat{F}_\ell^{n-j}\approx \hat{F}_\ell(t_{n-j})$</span>. </p><p>We can verify that the truncation error in this schema is  <span>${\mathcal O}(\Delta t^{r+1})$</span>, once the initial values  <span>$\hat{U}_\ell^1, \dots, \hat{U}_\ell^r$</span> have been calculated.  </p><h2 id="Non-homogeneous-case-f(u,-t)"><a class="docs-heading-anchor" href="#Non-homogeneous-case-f(u,-t)">Non-homogeneous case <span>$f(u, t)$</span></a><a id="Non-homogeneous-case-f(u,-t)-1"></a><a class="docs-heading-anchor-permalink" href="#Non-homogeneous-case-f(u,-t)" title="Permalink"></a></h2><p>Here we consider the case where <span>$f$</span> depends on the variable <span>$t$</span>.</p><p class="math-container">\[\frac{d u(t)}{dt} = \frac{1}{\varepsilon} A u(t) + f(u(t), t), \;\;\; u(t=t_{0})=u_{0}, \;\; \varepsilon\in ]0, 1] \;\;\;\; (3)\]</p><p>The non-homogeneous case (3) falls under (1), by entering the variable  <span>$\theta : t \in [t_{0}, t_{\text{end}}] \mapsto \theta(t) = t\in \mathbb{R}$</span>  which allows us to reformulate the non-homogeneous case (3) into a homogeneous problem of the form (1). Indeed, we rephrase (3) as follows</p><p class="math-container">\[\begin{aligned}
\frac{d u(t) }{dt}  &amp; = \frac{1}{\varepsilon} Au(t) + f(u(t), \theta(t)), \\
\frac{d \theta(t) }{dt}  &amp; = 1
\end{aligned}\;\;\;\;(4)\]</p><p>with the initial condition  <span>$u(t_{0})=u_{0}, \theta(t_{0})=t_{0}$</span>. Thus, the problem (4) is rewritten into an equation<br/>satisfied by <span>$y: t\in [t_{0}, t_{fin}] \mapsto y(t) =(u(t), \theta(t))\in \mathbb{R}^{n+1}$</span></p><p class="math-container">\[\frac{d y}{dt} = \frac{1}{\varepsilon} \tilde{A} y + g(y), \;\; y(t_{0})=(u_{0}, t_{0}),\]</p><p>with <span>$\tilde{A}\in{\mathcal M}_{n+1, n+1}(\mathbb{R})$</span></p><p class="math-container">\[\tilde{A}=
\left(
\begin{array}{cccc}
   &amp;    &amp;     &amp; 0 \\
   &amp; A &amp;     &amp; 0 \\
   &amp;    &amp;    &amp; 0 \\
0 &amp; 0 &amp; 0 &amp;  0 
\end{array}
\right) \;\;\;\; \text{ and } \;\;\;\;
g(y)=g(u, \theta) = \left(
\begin{array}{cccccc}
f(u, \theta) \\
1
\end{array}
\right) \in \mathbb{R}^{n+1}.\]</p><h1 id="Use"><a class="docs-heading-anchor" href="#Use">Use</a><a id="Use-1"></a><a class="docs-heading-anchor-permalink" href="#Use" title="Permalink"></a></h1><h2 id="Input-parameters"><a class="docs-heading-anchor" href="#Input-parameters">Input parameters</a><a id="Input-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Input-parameters" title="Permalink"></a></h2><p>The input arguments use the same format as the ODE package. </p><p>Thus, first of all, we must define the arguments necessary to construct the problem (1), namely</p><ul><li>the <span>$f$</span> function (in the form <em>Julia</em>) </li><li>the initial condition <span>$u_{0}$</span>.</li><li>the initial time <span>$t_{0}$</span> and final time <span>$t_{fin}$</span>. </li><li>the second parameter of the </li><li>the <span>$A$</span> matrix </li><li><span>$\varepsilon \in ]0, 1]$</span></li></ul><pre><code class="language-jl">pkg&#39;add https://gitlab.inria.fr/ua/HiOscSolver.jl.git&#39;
using HiOscSolver
A=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]
fct = (u,p,t) -&gt;  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] 
epsilon= 0.0001
t_min=0.0
t_max=3.0
u0 = [0.55, 0.12, 0.03, 0.89]
prob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon) </code></pre><p>From the <code>prob</code> problem, we can now switch to its digital resolution. </p><p>To do this, the numerical parameters are defined </p><ul><li>the number of time slots <span>$N_t$</span> which defines the time step <span>$\Delta t = \frac{t_{\text{end}}-t_0}{N_t}$</span> </li><li>the <span>$r$</span> order of the method </li><li>the number of <span>$N_\tau$</span> points in the <span>$\tau$</span> direction... </li><li>the order of preparation <span>$q$</span> of the initial condition </li></ul><p>The default settings are : <span>$N_t=100$</span>, <span>$r=4$</span>, <span>$N_\tau=32$</span> and <span>$q=r+2=6$</span> To solve the problem with the default parameters, just call the <code>solve</code> command with the problem already defined as parameter</p><pre><code class="language-jl">sol = solve(prob) </code></pre><p>Which is equivalent to this call</p><pre><code class="language-jl">sol = solve(
    prob;
    nb_tau=32, 
    order=4, 
    order_prep=6, # by default : order + 2
    dense=true, 
    nb_t=100, 
    getprecision=true, # by default : dense 
    verbose=100,    
    par_u0=missing,
    p_coef=missing,
) </code></pre><h3 id="Exhaustive-definition-of-the-parameters"><a class="docs-heading-anchor" href="#Exhaustive-definition-of-the-parameters">Exhaustive definition of the parameters</a><a id="Exhaustive-definition-of-the-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Exhaustive-definition-of-the-parameters" title="Permalink"></a></h3><ul><li><code>prob</code> : problem defined by <code>HiOscODEProblem</code> </li><li><code>nb_tau=32</code> : <span>$N_{\tau}$</span></li><li><code>order=4</code> : order <span>$r$</span> of the method</li><li><code>order_prep=order+2</code> : order of preparation of initial data</li><li><code>dense=true</code> : indicates whether or not to keep the data from the fourier transform, if <code>dense=false</code>, processing is faster but interpolation can no longer be done.</li><li><code>nb_t=100</code> : <span>$N_t$</span></li><li><code>getprecision=dense</code> : indicates whether the accuracy is calculated, the method used to calculate the accuracy multiplies the processing time by 2.</li><li><code>verbose=100</code> : trace level, if <code>verbose=0</code> then nothing is displayed.</li><li><code>par_u0</code> : If we have to make several calls to <code>solve</code> with the same initial data and in the same order, we can pass in parameter the already calculated data.</li><li><code>p_coef</code> : table with the coefficients of the Adams-Bashforth method. This array can be used to optimize several calls with the same parameters.</li></ul><h2 id="Exit-arguments"><a class="docs-heading-anchor" href="#Exit-arguments">Exit arguments</a><a id="Exit-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Exit-arguments" title="Permalink"></a></h2><p>As an output, a structure of type <code>HiOscODESolution</code>. This structure can be seen as a function of t, it can also be seen as an array of size <span>$N_t + 1$</span>. This structure also contains the <code>absprec</code> and <code>relprec</code> fields which are the absolute and relative precisions, respectively, calculated.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-jl">julia&gt; sol = solve(prob);
solve function prob=HiOscODEProblem with uType Array{Float64,1} and tType Float64. In-place: nothing
timespan: (0.0, 3.0)
u0: [0.55, 0.12, 0.03, 0.89],
 nb_tau=32, order=4, order_prep=6, dense=true,
 nb_t=100, getprecision=true, verbose=100

x 100/100

 99/99

julia&gt; t=2.541451547
2.541451547

julia&gt; sol(t)
4-element Array{Float64,1}:
 -0.536667845897295
  1.593257176840297
 -0.12420061944907212
  0.7184374612958457

julia&gt; sol[end]
4-element Array{Float64,1}:
  0.36316109321808354
  2.0379196624858955
 -0.4141248638226731
  1.3087136174628513

julia&gt; sol(3.0)
4-element Array{Float64,1}:
  0.36316109321808626
  2.037919662485913
 -0.4141248638226772
  1.308713617462862

julia&gt; sol.absprec
2.4721022528746903e-5

julia&gt; sol.relprec
9.952927361881597e-6

</code></pre><p>To view the result, you can also use Plot, for example</p><pre><code class="language-jl">using Plots
plot(sol) </code></pre><p>This results in</p><p><img src="../img/first.png" alt/></p><p>If you want to save the result in a file (pdf or png) here are the commands</p><pre><code class="language-jl">using Plots
p = plot(sol)
savefig(p,&quot;out/plot.png&quot;)</code></pre><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Hénon-Heiles"><a class="docs-heading-anchor" href="#Hénon-Heiles">Hénon-Heiles</a><a id="Hénon-Heiles-1"></a><a class="docs-heading-anchor-permalink" href="#Hénon-Heiles" title="Permalink"></a></h2><p>We consider the system of Hénon-Heiles satisfied by <span>$u(t)=(u_1, u_2, u_3, u_4)(t)$</span>.</p><p class="math-container">\[\frac{d u }{dt} = \frac{1}{\varepsilon} Au + f(u), \;\;\; u(0)=u_0\in\mathbb{R}^4,\]</p><p>where <span>$A$</span> and <span>$f$</span> are selected as follows</p><p class="math-container">\[A=
\left(
\begin{array}{cccc}
0 &amp; 0 &amp; 1 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0  \\
-1 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0  
\end{array}
\right) \;\;\;\; \text{ and } \;\;\;\;
f(u) = \left(
\begin{array}{cccc}
0 \\
u_4\\
-2 u_1 u_2\\
-u_2-u_1^2+u_2^2
\end{array}
\right).\]</p><p>one chooses for example, <span>$\varepsilon=0.001$</span> and <span>$u_0 = (0.12, 0.12, 0.12, 0.12)$</span></p><pre><code class="language-jl">using HiOscSolver
A=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]
fct = (u,p,t) -&gt;  [ 0, u[4], 2*u[1]*u[2], -u[2] - u[1]^2 + u[2]^2 ] 
epsilon= 0.001
t_min=0.0
t_max=1.0
u0 = [0.12, 0.12, 0.12, 0.12]
prob = HiOscODEProblem(fct, u0, (t_min,t_max), missing, A, epsilon)
sol = solve(prob);
using Plots
plot(sol)</code></pre><p><img src="../img/henon_heiles.png" alt/></p><h2 id="Charged-particle"><a class="docs-heading-anchor" href="#Charged-particle">Charged particle</a><a id="Charged-particle-1"></a><a class="docs-heading-anchor-permalink" href="#Charged-particle" title="Permalink"></a></h2><p>A system of charged particles under the effect of an external electro-magnetic field is considered to be  <span>$(E(t, x), B(t, x))\in \mathbb{R}^6$</span>.<br/>Particles are dynamically described by their position  <span>$x(t)\in\mathbb{R}^3$</span> and their speed <span>$v(t)\in\mathbb{R}^3$</span>. We&#39;ll index by <span>$i$</span> the <span>$i$</span>-th component of a vector. Newton&#39;s equations applied to a particle can be written as</p><p class="math-container">\[\begin{aligned}
\frac{d x(t) }{dt}&amp;= v(t) \\
\frac{d v(t) }{dt}&amp;= \frac{e}{m} \left[E(t, x(t)) + v(t)\times B(t, x(t))\right]. 
\end{aligned}\]</p><p>We will assume that the magnetic field is written <span>$B(t, x)=(0, 0, 1)^T$</span> and under a certain scaling, we consider the following equation</p><p class="math-container">\[\begin{aligned}
\frac{d x_1(t) }{dt} &amp;= \frac{1}{\varepsilon}v_1(t) \\
\frac{d x_2(t) }{dt} &amp;= \frac{1}{\varepsilon} v_2(t) \\
\frac{d x_3(t) }{dt} &amp;= v_3(t) \\
\frac{d v_1(t) }{dt} &amp;= E_1(t, x(t)) + \frac{1}{\varepsilon}v_2(t)\\
\frac{d v_2(t) }{dt} &amp;= E_2(t, x(t)) - \frac{1}{\varepsilon}v_1(t)\\
\frac{d v_3(t) }{dt} &amp;= E_3(t, x(t)) 
\end{aligned}\]</p><p>which is rewritten as follows</p><p class="math-container">\[\frac{d u(t) }{dt}= \frac{1}{\varepsilon}A u(t) + F(t, u(t)),\]</p><p>where the unknown vector <span>$u(t)=(x(t), v(t))\in\mathbb{R}^6$</span>, <span>$A$</span> is a square matrix of size <span>$6\times 6$</span> and <span>$F$</span> is a function with a value in <span>$\mathbb{R}^6$</span>. <span>$A$</span> and <span>$F$</span> are given by</p><p class="math-container">\[A=
\left(
\begin{array}{cccccc}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 
\end{array}
\right) \;\;\;\; \text{ and } \;\;\;\;
F(t, u(t)) = \left(
\begin{array}{cccccc}
0 \\
0\\
u_6(t)\\
E_1(t, u_1(t), u_2(t), u_3(t))\\
E_2(t,  u_1(t), u_2(t), u_3(t)\\
E_3(t,  u_1(t), u_2(t), u_3(t)
\end{array}
\right).\]</p><p>We can consider the following <span>$E=(E_1, E_2, E_3)$</span> function</p><p class="math-container">\[E(t, x) =
\left(
\begin{array}{ccc}
\cos(x_1/2)\sin(x_2)\sin(x_3)/2\\
\sin(x_1/2)\cos(x_2)\sin(x_3)\\
\sin(x_1/2)\sin(x_2)\cos(x_3)
\end{array}
\right)\]</p><pre><code class="language-jl">using HiOscSolver
A = [0 0 0 1 0 0; 0 0 0 0 1 0;0 0 0 0 0 0; 0 0 0 0 1 0; 0 0 0 -1 0 0; 0 0 0 0 0 0]
function fparticle(u, p, t)
    s1, c1 = sincos(u[1]/2)
    s2, c2 = sincos(u[2])
    s3, c3 = sincos(u[3])
    return [0, 0, u[6], c1*s2*s3/2, s1*c2*s3, s1*s2*c3]
end
epsilon= 0.05
t_min=0.0
t_max=1.0
u0 = [1.0, 1.5, -0.5, 0, -1.2, 0.8]
prob = HiOscODEProblem(fparticle, u0, (t_min,t_max), missing, A, epsilon)
sol=solve(prob)
plot(sol)</code></pre><p><img src="../img/particle.png" alt/></p><h2 id="Linear-non-homogeneous-case"><a class="docs-heading-anchor" href="#Linear-non-homogeneous-case">Linear non-homogeneous case</a><a id="Linear-non-homogeneous-case-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-non-homogeneous-case" title="Permalink"></a></h2><p>The following non-homogeneous linear system is considered to be satisfied by <span>$u(t)=(u_1, u_2, u_3, u_4)(t)$</span></p><p class="math-container">\[\frac{d u }{dt} = \frac{1}{\varepsilon} Au + f(t, u), \;\;\; u(0)=u_0\in\mathbb{R}^4,\]</p><p>where <span>$A$</span> and <span>$f$</span> are selected as follows</p><p class="math-container">\[A=
\left(
\begin{array}{cccc}
0 &amp; 0 &amp; 1 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0  \\
-1 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 0  
\end{array}
\right) \;\;\; \text{ and } \;\;\;
f(t, u) = Bu +\alpha t +\beta \;\; \text{ with  } \;\;
B\in {\mathcal M}_{4, 4}(\mathbb{R}), \alpha, \beta \in \mathbb{R}^4,\]</p><p><span>$B, \alpha, \beta$</span> are chosen randomly.</p><p>We wish to obtain a high precision, so we will use BigFloat real numbers, they are encoded on 256 bits by default which gives a precision bound of about <span>$2^{-256}. \approx 10^{-77}$</span>.<br/>At the end, we compare a calculated result with an exact result.</p><pre><code class="language-jl">using HiOscSolver
using Random
Random.seed!(1111)
A=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]
B = 2rand(BigFloat, 4, 4) - ones(BigFloat, 4, 4)
alpha = 2rand(BigFloat, 4) - ones(BigFloat, 4)
beta = 2rand(BigFloat, 4) - ones(BigFloat, 4)
fct = (u,p,t)-&gt; B*u + t*p[1] +p[2]
u0 = [big&quot;0.5&quot;, big&quot;-0.123&quot;, big&quot;0.8&quot;, big&quot;0.7&quot;]
t_min=big&quot;0.0&quot;
t_max=big&quot;1.0&quot;
epsilon=big&quot;0.017&quot;
prob = HiOscODEProblem(fct, u0, (t_min,t_max), (alpha, beta), A, epsilon, B)
sol = solve(prob, nb_t=10000, order=8)
sol.absprec
t=big&quot;0.9756534187771&quot;
sol(t)-getexactsol(sol.par_u0.parphi, u0, t)
using Plots
Plots.plot(sol.t,sol.u_tr)</code></pre><h3 id="Calculation-of-the-exact-solution"><a class="docs-heading-anchor" href="#Calculation-of-the-exact-solution">Calculation of the exact solution</a><a id="Calculation-of-the-exact-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Calculation-of-the-exact-solution" title="Permalink"></a></h3><p>This involves calculating the exact solution <span>$u(t)$</span> of the following equation at the instant <span>$t$</span></p><p class="math-container">\[\frac{d u }{dt} = \frac{1}{\varepsilon} Au + Bu +\alpha t +\beta, \;\;\; u(0)=u_0\in\mathbb{R}^4\text{, } A \text{ and }B \text{ are defined above }\]</p><p>Let</p><p class="math-container">\[\begin{aligned}
    M &amp;= \frac{1}{\varepsilon} A + B\\
    C &amp;= e^{-t_0 M}u_0 +M^{-1} e^{-t_0 M} (t_0\alpha+\beta)+ M^{-2} e^{-t_0 M} \alpha\\
    C_t &amp;= -M^{-1} e^{-t M} (t\alpha+\beta)-M^{-2} e^{-t M} \alpha\\
    u(t) &amp;= e^{t M} ( C + C_t)
\end{aligned}\]</p><p>Which, translated into Julia language, gives the code of the function <code>getexactsol</code> : </p><pre><code class="language-julia">function getexactsol(par::PreparePhi, u0, t)
    @assert !ismissing(par.matrix_B) &quot;The debug matrix is not defined&quot;
    sparse_A = par.sparse_Ap[1:(end-1),1:(end-1)]
    m = (1/par.epsilon)*sparse_A+par.matrix_B
    t0 = par.t_0
    if ismissing(par.paramfct)
        return exp((t-t0)*m)*u0
    end
    a, b = par.paramfct
    mm1 = m^(-1)
    mm2 = mm1^2
    e_t0 = exp(-t0*m)
    C = e_t0*u0 + mm1*e_t0*(t0*a+b)+mm2*e_t0*a
    e_inv = exp(-t*m)
    e = exp(t*m)
    C_t = -mm1*e_inv*(t*a+b)-mm2*e_inv*a
    return e*C+e*C_t
end
</code></pre><h2 id="Accuracy-of-the-result-according-to-the-time-interval"><a class="docs-heading-anchor" href="#Accuracy-of-the-result-according-to-the-time-interval">Accuracy of the result according to the time interval</a><a id="Accuracy-of-the-result-according-to-the-time-interval-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy-of-the-result-according-to-the-time-interval" title="Permalink"></a></h2><h3 id="Linear-problem"><a class="docs-heading-anchor" href="#Linear-problem">Linear problem</a><a id="Linear-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-problem" title="Permalink"></a></h3><p>From a problem of the previous type, as long as we can calculate the exact solution, it is possible to know exactly what the error is. The initialization data being</p><pre><code class="language-jl">using HiOscSolver
A=[0 0 1 0 ; 0 0 0 0 ; -1 0 0 0 ; 0 0 0 0]
u0 = BigFloat.([-34//100, 78//100, 67//100, -56//10])
B = BigFloat.([12//100 -78//100 91//100 34//100
    -45//100 56//100 3//100 54//100
    -67//100 09//100 18//100 89//100
    -91//100 -56//100 11//100 -56//100])
alpha =  BigFloat.([12//100, -98//100, 45//100, 26//100])
beta =  BigFloat.([-4//100, 48//100, 23//100, -87//100])
epsilon = 0.015
t_max = big&quot;1.0&quot;
fct = (u,p,t)-&gt; B*u + t*p[1] +p[2]
prob = HiOscODEProblem(fct,u0, (big&quot;0.0&quot;,t_max), (alpha, beta), A, epsilon, B)</code></pre><p>Note that the floats are coded on 512 bits.<br/>By varying <span>$\Delta t$</span> from <span>$10^{-2}$</span> to <span>$5.10^{-6}$</span> (i.e. <code>nb_t</code> from <code>100</code> to <code>204800</code>) on a logarithmic scale, for odd orders from 3 to 17 we get these errors</p><h4 id="Precision-of-the-result-with-ε-0.015"><a class="docs-heading-anchor" href="#Precision-of-the-result-with-ε-0.015">Precision of the result with ε = 0.015</a><a id="Precision-of-the-result-with-ε-0.015-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-of-the-result-with-ε-0.015" title="Permalink"></a></h4><p><img src="../img/error_order.png" alt/></p><p>Now with the same initial data, order being setted to 6, and <span>$\varepsilon = 0.15, 0.015, \ldots, 1.5\times 10^{-7}$</span>.<br/>Here floats are coded on 256 bits.</p><h4 id="Precision-of-the-result-with-order-6"><a class="docs-heading-anchor" href="#Precision-of-the-result-with-order-6">Precision of the result with order = 6</a><a id="Precision-of-the-result-with-order-6-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-of-the-result-with-order-6" title="Permalink"></a></h4><p><img src="../img/error_epsilon.png" alt/></p><h3 id="Problem-with-Hénon-Heiles-function"><a class="docs-heading-anchor" href="#Problem-with-Hénon-Heiles-function">Problem with Hénon-Heiles function</a><a id="Problem-with-Hénon-Heiles-function-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-with-Hénon-Heiles-function" title="Permalink"></a></h3><pre><code class="language-jl">    u0=BigFloat.([90, -44, 83, 13]//100)
    t_max = big&quot;1.0&quot;
    epsilon=big&quot;0.0017&quot;
    fct = u -&gt; [0, u[4], -2u[1]*u[2], -u[2]-u[1]^2+u[2]^2]
    A = [0 0 1 0; 0 0 0 0;-1 0 0 0; 0 0 0 0]
    prob = HiOscODEProblem(fct, u0, (big&quot;0.0&quot;,t_max), missing, A, epsilon)</code></pre><p>The float are coded on 512 bits.</p><h4 id="Precision-of-the-result-with-ε-0.0017"><a class="docs-heading-anchor" href="#Precision-of-the-result-with-ε-0.0017">Precision of the result with ε = 0.0017</a><a id="Precision-of-the-result-with-ε-0.0017-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-of-the-result-with-ε-0.0017" title="Permalink"></a></h4><p><img src="../img/error_order_hh.png" alt/></p><p>Now with the same initial data, order being setted to 6, and <span>$\varepsilon = 0.19, 0.019, \ldots, 1.9\times 10^{-8}$</span>.<br/>Here floats are coded on 256 bits.</p><h4 id="Precision-of-the-result-with-ordre-6"><a class="docs-heading-anchor" href="#Precision-of-the-result-with-ordre-6">Precision of the result with ordre = 6</a><a id="Precision-of-the-result-with-ordre-6-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-of-the-result-with-ordre-6" title="Permalink"></a></h4><p><img src="../img/error_epsilon_hh.png" alt/></p><h2 id="Future-work"><a class="docs-heading-anchor" href="#Future-work">Future work</a><a id="Future-work-1"></a><a class="docs-heading-anchor-permalink" href="#Future-work" title="Permalink"></a></h2><ul><li>precision on parameter.</li><li>exponential runge-kutta method</li></ul><h3 id="The-&quot;classical&quot;-Runge-Kutta-method-(order-4)-adapted-to-the-exponential-(not-yet-implemented)"><a class="docs-heading-anchor" href="#The-&quot;classical&quot;-Runge-Kutta-method-(order-4)-adapted-to-the-exponential-(not-yet-implemented)">The &quot;classical&quot; Runge-Kutta method (order 4) adapted to the exponential (not yet implemented)</a><a id="The-&quot;classical&quot;-Runge-Kutta-method-(order-4)-adapted-to-the-exponential-(not-yet-implemented)-1"></a><a class="docs-heading-anchor-permalink" href="#The-&quot;classical&quot;-Runge-Kutta-method-(order-4)-adapted-to-the-exponential-(not-yet-implemented)" title="Permalink"></a></h3><p>Notations : </p><ul><li>We denote by <span>$G$</span> the function which transforms <span>$\hat{U}$</span> to <span>$\hat{f}$</span>, so <span>$G(\hat{U}) = \hat{f}$</span>.</li><li>We denote by <span>$S_{t_0}^{t_1}(t_2,\ell)$</span> the intégral <span>$S_{t_0}^{t_1}(t_2,\ell) = \int_{t_0}^{t_1} e^{- i \ell (t_2 - s)/\varepsilon} ds = ( i \varepsilon / \ell) ( e^{- i \ell (t_2 - t_1)/\varepsilon}-e^{- i \ell (t_2 - t_0)/\varepsilon})$</span></li></ul><p>Here are the calculations</p><ul><li><p><span>$u_{1,\ell} = \hat{U}_{n, \ell}$</span></p></li><li><p><span>$u_{2,\ell} = e^{- i \ell h_n /(2 \varepsilon)}\hat{U}_{n, \ell} + S_0^{h_n /2} ( h_n /2,\ell ) G_{\ell}(u_1)$</span></p></li><li><p><span>$u_{3,\ell} = e^{- i \ell h_n /(2 \varepsilon)}\hat{U}_{n, \ell} + S_0^{h_n /2} ( h_n /2,\ell )  G_{\ell}(u_2)$</span></p></li><li><p><span>$u_{4,\ell} = e^{- i \ell h_n /(2\varepsilon)}u_{2,\ell} + S_0^{h_n/2} ( h_n/2,\ell )[ 2 G_{\ell}(u_3)-G_{\ell}(u_1)]$</span> (see (28) of <a href="../#cox2002">S.M. Cox , P.C. Matthews  (2002)</a>, with <span>$c=-i \ell h_n /\varepsilon$</span>)   </p></li></ul><p>From (29) of <a href="../#cox2002">S.M. Cox , P.C. Matthews  (2002)</a>, with <span>$c=-i \ell h_n /\varepsilon$</span>, we have</p><p class="math-container">\[\hat{U}_{n+1, \ell} = e^{- i \ell h_n /\varepsilon}\hat{U}_{n, \ell} +  G_{\ell}(u_1) [-4+i \ell h_n /\varepsilon + e^{-i \ell h_n /\varepsilon}(4+3i \ell h_n /\varepsilon+(i \ell h_n /\varepsilon)^2]\\+ (2 G_{\ell}(u_2) + G_{\ell}(u_3) )[-2-i \ell h_n /\varepsilon+e^{-i \ell h_n /\varepsilon}(2-i \ell h_n /\varepsilon)]\\ + G_{\ell}(u_4)[-4+3i \ell h_n /\varepsilon -(i \ell h_n /\varepsilon)^2 + e^{-i \ell h_n /\varepsilon}(4+i \ell h_n /\varepsilon)]/(h_n^2 (i \ell h_n /\varepsilon)^3)\]</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 10 December 2020 08:14">Thursday 10 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
